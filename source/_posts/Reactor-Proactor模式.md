---
title: Reactor/Proactor模式
date: 2024-06-06 15:39:44
tags: C++ 网络编程 Reactor
categories:
    笔记
---

# 服务器的演变

1. 为每个连接创建一个进程/线程（不断的创建和销毁进程/线程，带来很大的性能开销，造成资源浪费）
2. 创建线程池（无法高效的处理多个连接业务，一个线程处理多个连接的业务时，线程在处理某个连接的`read`操作（默认是阻塞的）时，如果一直没有数据可读，就会阻塞，线程就无法处理其他业务）
3. 将阻塞IO改为非阻塞IO (线程会不断的轮询调用`read`来判断是否有数据，轮询是消耗CPU的，而且随着一个线程要处理的连接越多，轮询的效率就会越低)
4. I/O多路复用（不需要轮询，用系统调用函数监听关心的事件，注册回调，没有事情发生时，会阻塞在这个系统调用，而不是像线程池那样轮询调用`read`）
5. 使用`Reactor/Proactor`模式：将IO事件与业务分离，解耦

## 阻塞IO和非阻塞IO

- 针对阻塞 I/O 执行的系统调用可能因为无法立即完成而被操作系统挂起，直到等待的事件发生为止。可能被阻塞的系统调用为 **accept**、**send**、**recv** 和 **connect**；
- 针对非阻塞 I/O 执行的系统调用则总是立即返回，而不管事件是否已经发生。如果事件没有立即发生，这些系统调用就返回 `-1`，和出错的情况一样。此时我们必须根据 `errno` 来区分这两种情况。
  - 对 **accept**、**send**、**recv** 而言，事件未发生时 `errno` 通常被设置为 `EAGAIN`（意为“再来一次”）或者 `EWOUDBLOCK`（意为“期望阻塞”）；
  - 对 **connect** 而言，`errno` 则被设置成 `EINPROGRESS`（意为“在处理中”）。

**阻塞等待的是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程**

## 同步IO和异步IO

- 同步IO：请求时，如果数据未准备好，会一直阻塞进程，直到IO操作完成
- 异步IO:请求时，不管数据是否准备好，都立即返回

## 什么情况下需要I/O多路复用技术

传统的 I/O 模型中，每个连接或操作都需要一个独立的线程或进程来处理，这会消耗大量的系统资源。而使用 I/O 多路复用技术，可以通过一个线程或进程同时监听多个 I/O 事件，从而减少了资源的消耗。

**IO多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态**，比如调用select和poll函数，传入多个文件描述符，**如果有一个文件描述符就绪，则返回，否则阻塞直到超时**。

这样在处理1000个连接时，**只需要1个线程监控就绪状态，对就绪的每个连接开一个线程处理就可以了，这样需要的线程数大大减少，减少了内存开销和上下文切换的CPU开销。**

## 五种I/O模型

**阻塞 I/O 模型（Blocking I/O）：**

- 在阻塞 I/O 模型中，当应用程序发起一个 I/O 操作时，它会被阻塞，直到操作完成。
- 这意味着应用程序无法执行其他任务，直到 I/O 操作完成。

**非阻塞 I/O 模型（Non-blocking I/O）：**

- 在非阻塞 I/O 模型中，应用程序可以继续执行其他任务而不必等待 I/O 操作的完成。
- 当一个 I/O 操作发起后，应用程序可以立即返回并执行其他任务，然后周期性地检查 I/O 操作是否完成。

**多路复用 I/O 模型（I/O Multiplexing）：**

- 多路复用 I/O 模型使用 `select`、`poll` 或 `epoll` 等机制，允许应用程序监视多个文件描述符，等待其中任何一个变为可读或可写状态。
- 当有数据准备好时，应用程序会得到通知，然后可以进行读或写操作。

**信号驱动IO**

- linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。

**阻塞I/O，非阻塞I/O，信号驱动I/O和I/O复用都是同步I/O。同步I/O指内核向应用程序通知的是就绪事件，比如只通知有客户端连接，要求用户代码自行执行I/O操作，异步I/O是指内核向应用程序通知的是完成事件，比如读取客户端的数据后才通知应用程序，由内核完成I/O操作。**

[UNIX五种IO模型 | 蓝亭书序 (lantingshuxu.github.io)](https://lantingshuxu.github.io/其他/UNIX五种IO模型/)

## Reactor模式和Proactor模式

- `Reactor`模式要求主线程（I/O 处理单元）**只负责监听文件描述符上是否有事件发生**。有的话立即通知工作线程（逻辑单元），读写数据、接受新的连接及处理客户请求均在工作线程中完成。通常由同步I/O实现。

- `Proactor`模式将所有的 I/O 操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。通常由异步 I/O （`aio_read()`和`aid_write()`）实现。

因此，**Reactor 可以理解为「来了事件操作系统通知应用进程，让应用进程来处理」**，而 **Proactor 可以理解为「来了事件操作系统来处理，处理完再通知应用进程」**。

**Reactor 模式是基于「待完成」的 I/O 事件，而 Proactor 模式则是基于「已完成」的 I/O 事件**。

