---
title: C++基础面试题杂项
date: 2024-06-21 16:27:12
tags: C++
categories:
    C++基础
---

1. 除了多态和继承还有什么面向对象方法

   1. **封装**是将对象的状态（属性）和行为（方法）隐藏在对象内部，并通过公共接口（公共方法）与外部进行交互。这样可以保护对象的内部状态不被外部直接访问和修改，从而提高代码的安全性和维护性。
   2. **抽象**是从具体的实例中提取出共有的特征，将不必要的细节隐藏起来。通过抽象，可以创建更加通用和简洁的模型。
   3. **组合**是通过将对象包含在其他对象内部来构建复杂对象的过程。聚合是较松散的一种对象组合关系，表示“整体-部分”的关系。

2. C++内存分布。什么样的数据在栈区，什么样的在堆区

   1. **栈区**用于存储局部变量、函数参数和返回地址。栈区的内存分配由编译器自动管理，具有自动回收的特性。当函数调用时，局部变量和函数参数会被压入栈中；当函数返回时，这些数据会被弹出栈。
      - **局部变量**：在函数内部声明的变量。

      - **函数参数**：传递给函数的参数。

      - **返回地址**：用于保存函数调用的返回地址。

   2. **堆区**用于动态分配内存，生命周期由程序员控制。堆区的内存分配和释放需要使用 `new` 和 `delete` 运算符。堆区适合用于需要在运行时决定大小并且生命周期不局限于单个函数调用的内存。

      - **动态分配的对象和数组**：使用 `new` 和 `delete` 运算符分配和释放的内存。

   3. **全局区**用于存储全局变量和静态变量。全局变量在整个程序生命周期内有效。静态变量在它们所属的作用域内有效，但它们的生命周期是整个程序运行期间。

      - **全局变量**：在所有函数之外声明的变量。
      - **静态变量**：使用 `static` 关键字声明的变量，无论是在函数内部还是类内部。
      - **静态成员变量**：在类中使用 `static` 关键字声明的静态成员变量。

   4. **常量区**用于存储常量数据和未初始化的全局/静态变量。常量区的数据在程序运行期间是只读的。

      - **字符串字面量**：使用双引号括起来的字符串。
      - **const 变量**：用 `const` 关键字声明的变量。

   5. **代码区**用于存储程序的可执行代码，包括函数和方法的机器指令。这些指令在程序加载时被操作系统加载到内存中，并且通常是只读的。

   ![image-20240612122221519](https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/image-20240612122221519.png)

3. C++内存管理（RAII啥的）

4. C++从源程序到可执行程序的过程

   1. 预处理：	将宏定义展开（**预处理过程主要处理那些源文件中的以“#”开始的预编译指令**）
   2. 编译：   将源文件编译为汇编语言（编译过程就是把预处理的文件进行一系列的**词法分析**，**语法分析**，**语义分析**以及**优化后产生相应的汇编代码文件**。）
   3. 汇编：   将汇报文件转换为机器码，生成可重定位目标文件
   4. 链接：将多个目标文件及所需要的库连接成最终的可执行目标文件。

5. 一个对象=另一个对象会发生什么（赋值构造函数）

6. 如果new了之后出了问题直接return。会导致内存泄漏。怎么办
   （智能指针，raii，stl容器）

7. 多进程fork后不同进程会共享哪些资源

   **文件描述符**：父子进程共享文件描述符所指向的文件表项。这意味着对文件描述符的操作（如读写文件指针的移动）会相互影响。

   **文件锁**：父子进程之间共享文件锁。

   **信号处理程序**：父子进程共享信号处理程序的设置。

   **消息队列、信号量和共享内存**：如果父进程使用了这些进程间通信机制，子进程将共享这些资源。

8. 多线程里线程的同步方式有哪些

   1. 互斥锁是一种用于保护临界区的同步机制，它确保同一时刻只有一个线程能够进入临界区执行代码，从而避免多个线程同时访问共享资源而导致的数据竞争和错误。互斥锁通过 `pthread_mutex_init()、pthread_mutex_lock() 和 pthread_mutex_unlock() `等函数来进行操作。
   2. 读写锁允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。这种机制适用于读操作频繁而写操作较少的场景，可以提高程序的并发性能。读写锁通过 `pthread_rwlock_init()、pthread_rwlock_rdlock() 和 pthread_rwlock_wrlock() `等函数来进行操作。
   3. 条件变量是一种用于线程间等待和通知的机制，允许线程等待某个条件达成后再继续执行。条件变量通常与互斥锁配合使用，以确保线程在等待和通知的过程中能够安全地访问共享资源。条件变量通过 `pthread_cond_init()、pthread_cond_wait() 和 pthread_cond_signal() `等函数来进行操作。
   4. 在线程间通信中，信号量通常用于控制对临界资源的访问，类似于进程间通信中的信号量。线程间信号量可以用于实现互斥和同步，确保多个线程之间的协同工作。信号量通过 s`em_init()、sem_wait() 和 sem_post() `等函数来进行操作。
   5. 原子操作

9. size_of是在编译期还是在运行期确定

   在C++中，`sizeof`运算符的计算是在编译期确定的，而不是在运行期确定的。`sizeof`用于获取类型或对象的大小（以字节为单位），并且其结果在编译时就已经固定，不会在运行时再进行计算。

10. 函数重载的机制。重载是在编译期还是在运行期确定

    函数重载是C++中的一种静态多态性，通过允许在同一作用域内定义多个同名但参数列表不同的函数来实现。重载机制在编译期由编译器确定，而不是在运行期确定。

11. 指针常量和常量指针

    > 常量指针:常量指针指向一个常量值，这意味着通过这个指针不能修改所指向的对象。指针本身可以改变，指向不同的对象。
    >
    > ```c++
    > int x = 10;
    > int y = 20;
    > const int *ptr = &x;  // ptr 是一个常量指针，可以改变指向对象，但不能通过 ptr 修改 x 的值
    > 
    > ptr = &y;  // 合法，ptr 可以指向不同的对象
    > *ptr = 30; // 非法，不能通过 ptr 修改 y 的值
    > ```
    >
    > 指针常量：指针常量是一个指针变量，它被初始化后就不能改变其指向的对象，但通过这个指针可以修改对象的值。
    >
    > ```c++
    > int x = 10;
    > int y = 20;
    > int *const ptr = &x;  // ptr 是一个指针常量，不能改变指向，但可以通过 ptr 修改 x 的值
    > 
    > ptr = &y;   // 非法，ptr 不能指向不同的对象
    > *ptr = 30;  // 合法，可以通过 ptr 修改 x 的值
    > ```

12. vector的原理，怎么扩容

    `std::vector` 是 C++ 标准库中的一个动态数组容器，它可以自动调整大小以适应元素的增加或减少。其底层实现依赖于动态分配内存，并在需要时进行扩容。

    >**`std::vector` 的扩容机制**
    >
    >当 `std::vector` 需要增加元素且当前容量不足时，它会执行以下步骤进行扩容：
    >
    >1. **分配新的内存块**：`std::vector` 会分配一个更大的内存块。新容量一般是旧容量的两倍，以平衡扩容次数和内存使用效率。
    >2. **复制元素**：将旧内存块中的所有元素复制到新的内存块中。这涉及到调用元素的复制构造函数。
    >3. **释放旧内存块**：释放旧的内存块，避免内存泄漏。
    >4. **更新内部指针**：更新内部指针以指向新的内存块，并调整容量信息。

13. 介绍一下const

    在 C++ 中，`const` 关键字用于定义常量或者防止变量被修改。它可以应用于变量、指针、成员函数等，以增加代码的安全性和可读性。

14. 引用和指针的区别

    1. 指针可以为空，如指向`nullptr`；引用不能为空
    2. 指针可以改变所指的对象，引用初始化后不能被改变
    3. 指针是一个实体，由内存的；引用仅是个别名

15. RAII基于什么实现的（生命周期、作用域、构造析构）

    RAII 基于 C++ 对象的生命周期、作用域以及构造函数和析构函数来实现。

16. 手撕：Unique_ptr，控制权转移(移动语义）手撕：类继承，堆栈上分别代码实现多态

17. 右值引用

    **左值（Lvalue）**：表示一个有名字的变量或内存中的一个位置，可以取其地址。例如，变量 `x`、数组元素 `arr[i]`、解引用指针 `*ptr` 等。

    **右值（Rvalue）**：表示一个临时值或不具名的对象，通常是表达式的结果，不能取其地址。例如，字面值 `42`、表达式 `x + y` 的结果等。

    **右值引用（rvalue reference）**：使用 `&&` 表示，允许你绑定到右值。右值引用主要用于实现**移动语义**和**完美转发**。

18. 函数参数可不可以传右值

    **右值引用（rvalue reference）**：使用 `&&` 表示，允许你绑定到右值。右值引用的主要目的是支持移动语义和避免拷贝开销。通过右值引用，函数参数可以直接接收右值，从而实现高效的资源管理。

19. 参考c/c++堆栈实现自己的堆栈。要求：不能用stl容器。

20. stl容器了解吗？底层如何实现：vector数组，map红黑树，红黑树的实现

21. 完美转发介绍一下 去掉std::forward会怎样？

    完美转发的目标是保证函数模板在传递参数时，不改变参数的类型特性。例如，如果传递的是左值，则保持左值；如果传递的是右值，则保持右值。

    1. **万能引用（Universal Reference）**：函数模板参数类型 `T&&` 可以同时匹配左值和右值。

    2. **`std::forward`**：用于保持参数的类型特性进行转发。

22. 介绍一下unique_lock和lock_guard区别？

    1. `std::lock_guard`：

       `std::lock_guard` 是一个简单的、轻量级的 RAII（Resource Acquisition Is Initialization）锁管理类。它在构造时锁定互斥锁，在析构时解锁。`std::lock_guard` 不能显式地锁定或解锁互斥锁，也不能在作用域内转移锁的所有权。

    2. `std::unique_lock`

       `std::unique_lock` 是一个更灵活的锁管理类，提供了比 `std::lock_guard` 更多的功能。它允许显式地锁定和解锁，延迟锁定，尝试锁定，甚至在作用域内转移锁的所有权。

23. C代码中引用C++代码有时候会报错为什么？

    C++编译器为了支持函数重载和其他C++特性，会对函数名进行修饰，使得函数名在生成的目标文件中并不是其原始名称。这使得C语言编译器在链接时无法找到这些函数，因为C语言不支持函数重载，也不会对函数名进行修饰。

    `extern "C"`：为了让C++编译器生成与C兼容的函数名，可以使用`extern "C"`来禁用名字修饰。`extern "C"`告诉C++编译器按照C的方式处理指定的代码，使其可以被C代码引用。使用`extern "C"`来保护声明，使得C编译器能够正确地解析和链接这些符号。

24. 静态多态有什么？虚函数原理：虚表是什么时候建立的？为什么要把析构函数设置成虚函数？

    > 静态多态性在编译时确定，主要通过函数重载和模板实现。
    >
    > 1. **函数重载（Function Overloading）**：同一作用域内的多个函数可以有相同的名字，但参数列表不同，编译器根据传递的参数类型和数量选择适当的函数。
    > 2. **模板**：模板允许定义通用函数和类，使得在编译时生成具体类型的实例。

25. map为啥用红黑树不用avl树？（几乎所有面试都问了map和unordered_map区别）

    1. 红黑树：

    应用场景：适用于需要频繁插入、删除、查找操作且数据量较大，要求有序性的情况。
    优点：① 具有平衡性，插入、删除、查找的时间复杂度为O ( l o g n ) O(logn)O(logn)；② 支持有序遍历；③ 可用于实现有序集合、有序映射等场景。
    缺点：①相对于散列表来说，需要更多的内存空间；②对于基于散列的操作，如随机访问，并不擅长。

    2. 散列表：

    应用场景：适用于需要频繁插入、删除、查找操作且数据量较大，不需要有序性的情况。

    优点：①查找、插入、删除的平均时间复杂度为O(1)，最坏时间复杂度是O(n)；②支持随机访问，性能通常比树要好。

    缺点：①可能会出现哈希冲突，需要使用冲突解决方法，如链表法、开放寻址法等；②散列表的元素是无序的，不支持有序遍历。

    - 在空间利用率方面，散列表会占用更多的空间，因为它需要额外的空间来存储哈希表的桶和哈希冲突解决方法所需的链表或探测序列等。而红黑树只需要存储节点数据和指向左右子树的指针。因此，红黑树在空间利用率方面相对于散列表更为优秀。

    - 空间复杂度：散列表的空间复杂度会随着元素数量的增加而增加，而红黑树的空间复杂度与元素数量无关，只与树的高度有关。因此，在元素数量较大时，红黑树的空间复杂度相对于散列表更优秀。

    >1. 红黑树的查询效率比散列表更为稳定，不会因为哈希冲突等因素而导致查询性能下降。在查询方面，红黑树的时间复杂度为O(log n)（n为树中元素个数），而散列表的查询时间复杂度为O(1)。但是，在涉及到大量数据的情况下，红黑树的常数因子更小，查询效率更高。
    >
    >2. 红黑树的插入和删除操作的时间复杂度也为O(log n)，相对于散列表来说更为稳定，不会因为哈希冲突等因素导致性能下降。
    >
    >3. 红黑树是一种平衡二叉搜索树，具有良好的稳定性。在任何情况下，红黑树的平衡性都能得到保持。而散列表的性能会因为哈希冲突等因素而不稳定。
    >
    >4. 红黑树相对于散列表来说，内存消耗更为稳定，不会因为哈希冲突等因素而引起内存的浪费。
    >
    >5. 红黑树是一种有序树结构，可以维护元素的顺序，而散列表是一种无序结构，不适用于需要维护元素顺序的场合。
    >
    >6. 红黑树支持动态扩容和缩容，而散列表需要重新计算哈希函数，重新分配内存等过程，相对来说比较复杂。

26. inline 失效场景

    >`inline` 关键字用于提示编译器尝试将函数的调用展开为函数体，以减少函数调用的开销。然而，`inline` 只是一个建议，编译器可以选择忽略这个建议。

    1. 如果函数体太大或太复杂，编译器可能会选择不进行内联展开，因为这样做可能会导致代码膨胀，进而影响性能。
    2. 递归函数通常不会被内联展开，因为内联展开递归函数会导致无限展开。
    3. 虚函数通常不会被内联展开，因为虚函数的调用在运行时通过虚函数表（vtable）进行，编译器在编译时无法确定实际调用的是哪个函数。

27. C++ 中 struct 和 class 区别

    1. 默认访问权限

    - **struct**：默认情况下，`struct` 的成员和继承是公有的（`public`）。
    - **class**：默认情况下，`class` 的成员和继承是私有的（`private`）。

    2. 继承方式

    - **struct**：`struct` 的默认继承方式是公有继承（`public`）。
    - **class**：`class` 的默认继承方式是私有继承（`private`）。

28. 如何防止一个头文件 include 多次

    1. `#pragma once` 

    2. ```c++
       #ifndef HEADER_FILE_NAME_H
       #define HEADER_FILE_NAME_H
       
       // 头文件内容
       
       #endif // HEADER_FILE_NAME_H
       ```

29. lambda表达式的理解，它可以捕获哪些类型

    > `lambda`表达式允许捕获一定范围内的变量：
    >
    > - `[]`不捕获任何变量
    > - `[&]`引用捕获，捕获外部作用域所有变量，在函数体内当作引用使用
    > - `[=]`值捕获，捕获外部作用域所有变量，在函数内内有个副本使用
    > - `[=, &a]`值捕获外部作用域所有变量，按引用捕获a变量
    > - `[a]`只值捕获a变量，不捕获其它变量
    > - `[this]`捕获当前类中的this指针

30. 友元friend介绍

    在 C++ 中，友元（`friend`）是一种允许一个类或函数访问另一个类的私有（`private`）或受保护（`protected`）成员的机制。友元关系在类定义时声明，并且可以是友元函数或友元类。友元不是类的成员，但它们可以访问类的私有和受保护成员。

    友元的主要用途是**允许紧密耦合的类或函数访问彼此的内部实现，而无需公开其内部数据或方法**。

31. move函数

    用于将一个对象转换为右值引用。右值引用允许移动语义的实现，这是一种通过转移资源（如内存、文件句柄等）而不是复制资源来优化性能的方法。

32. 模版类的作用

33. 模版和泛型的区别

34. 内存管理：C++的new和malloc的区别

    都可以用来在**堆上分配和回收空间**。`new /delete` 是操作符，`malloc/free `是库函数。

    {% note success %}

    **执行 new 实际上执行两个过程**：

    1. 分配未初始化的内存空间（malloc）；

    2. 使用对象的构造函数对空间进行初始化；返回空间的首地址。

    如果在第一步分配空间中出现问题，则抛出` std::bad_alloc `异常，或被某个设定的异常处理函数捕获处理；如果在第二步构造对象时出现异常，则自动调用` delete `释放内存。

    {% endnote %}

    {% note success %}

    **执行 delete 实际上也有两个过程**：

    1. 使用析构函数对对象进行析构；
    2. 回收内存空间（free）。

    以上也可以看出` new `和 `malloc` 的区别，`new `得到的是**经过初始化的空间**，而` malloc `得到的是**未初始化的空间**。所以 `new` 是 `new` 一个类型，而 `malloc `则是`malloc`一个字节长度的空间。`delete `和` free`同理，`delete`不仅释放空间还析构对象，`delete` 一个类型，`free` 一个字节长度的空间。

    {% endnote %}

    **为什么有了 malloc／free ,还需要 new／delete？** 

    因为对于非内部数据类型而言，光用 `malloc／free `无法满足动态对象的要求。对象在创建的同时需要自动执行构造函数，对象在消亡以前要自动执行析构函数。由于 `mallo／free `是库函数而不是运算符，不在编译器控制权限之内，不能够把执行的构造函数和析构函数的任务强加于 `malloc／free`，所以有了` new／delete `操作符。

35. new可以重载吗，可以改写new函数吗

    可以，并添加自定义的打印

36. C++中的map和unordered_map的区别和使用场景

37. 他们是线程安全的吗

    不是线程安全的

38. c++标准库里优先队列是怎么实现的？

39. gcc编译的过程

40. C++ Coroutine

41. extern C有什么作用

    `extern "C"` 是 C++ 中的一个关键字组合，用于指示编译器按照 C 的方式来处理被其修饰的代码。这在需要与 C 代码或使用 C 编译器编译的库进行互操作时特别有用。

    1. 函数名修饰

    C++ 编译器会对函数名进行修饰，以支持函数重载和其他 C++ 特性。这种修饰会导致编译器生成的符号名与源代码中的函数名不同。而 C 编译器不会进行这种修饰。因此，为了确保 C++ 代码可以链接到使用 C 编译器编译的库（或反之），需要禁用 C++ 的函数名修饰，这正是 `extern "C"` 的作用。

    2. C 和 C++ 互操作

    通过 `extern "C"`，可以确保 C++ 编译器生成的符号名与 C 编译器生成的符号名匹配，从而使 C++ 代码能够调用 C 函数，或使 C 函数能够调用 C++ 函数。