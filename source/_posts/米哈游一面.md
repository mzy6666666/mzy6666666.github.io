---
title: 米哈游一面
date: 2024-09-01 16:55:36
tags: 面试
categories:
    面试
password: mzy666
abstract: 有东西被加密了, 请输入密码查看.
message: 您好, 这里需要密码.
wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试.
wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.
---

# 米哈游一面

1. 讲一下智能指针

> C++使用内存的时候很容易出现野指针、指针悬空、内存泄漏的情况，所以引入了智能指针，智能指针是以`RAII`的技术来封装普通指针，能自动释放动态分配的对象，防止堆内存泄漏。
>
> `shared_ptr`：共享指针，采用引用计数的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加1，每当减少一个智能指针指向对象时，引用计数减1，当计数为0时就会自动的释放动态内存
>
> `unique_ptr`：独享指针，同一时刻只能有一个指针指向同一个对象，不支持拷贝操作，可以讲对象所有权转移
>
> `weak_ptr`：弱引用，它不对所指向的对象的内存进行管理。通常与`shared_ptr`一起使用，防止循环引用的问题

> 野指针：指针声明没有初始化
>
> 指针悬空：指针指向的内存在某个时刻被释放了，但是指针没有被相应的更新或者置空。如数组删除了第一位的内存

1. 手写一个循环引用的例子

> 
>
> > 循环引用
> >
> > ```c++
> > #include <iostream>
> > #include <memory>
> > 
> > using namespace std;
> > 
> > class B; // 前向声明
> > class A {
> > public:
> > std::shared_ptr<B> b_ptr;
> > };
> > 
> > class A; // 前向声明
> > class B {
> > public:
> > std::shared_ptr<A> a_ptr;
> > };
> > 
> > int main() {
> > std::shared_ptr<A> a = std::make_shared<A>();
> > std::shared_ptr<B> b = std::make_shared<B>();
> > a->b_ptr = b;
> > b->a_ptr = a;
> > return 0;
> > }
> > 
> > ```

讲一下static关键字

> 1. 修饰普通变量，使变量存储在静态区，在main函数之前就分配了空间，如果有初始值就用初始值初始化，没有就默认值初始化，生命周期延长到整个函数执行期间，但只在定义它的源文件中可见
> 2. 修饰成员变量，所有对象只保存一个该变量，而且不需要生成对象就可以访问成员
> 3. 修饰成员函数，不需要生成对象就可以访问，静态成员函数没有`this`指针
>
> 静态变量只会初始化一次，静态变量放在全局区，所以在主程序之前就会分配内存

static内存位置和初始化

了解多态吗

> 编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，虚表里保存了虚函数的入口函数
>
> 在派生类定义对象时，程序会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。在构造子类对象时，会先调用父类的构造函数，此时，编译器只看见父类，并为父类对象初始化虚表指针，令它指向父类的虚表；当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表

1. 动态多态是用来解决什么问题的
2. 正常继承也能也能实现重写
3. 多态的实现原理
4. 纯虚函数知道吗
5. 和普通虚函数有什么区别
6. 虚析构函数知道吗

> 由于类的多态性，基类指针可以指向派生类的对象，如果删除该基类的指针，就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。

进程和线程的区别

> 1. 进程是资源分配的基本单位，线程是cpu调度的基本单位
> 2. 进程cpu环境的保存以及上线文切换销毁比线程高
> 3. 不同进程之间切换实现并发，各自占有cpu实现并行；一个进程内部的多个线程并发执行
> 4. 

进程和线程共享和独立的资源

>共享：堆、内存资源、句柄、文件描述符
>
>独立：栈、寄存器、程序计数器

linux下的孤儿进程和僵尸进程

linux下查看cpu占用，内存和端口占用

top发现进程跑100%

如果不是死循环，还有其他情况吗

> 1. 死锁
> 2. 竞争资源
> 3. 高计算

用什么命令干掉程序

kill是怎么干掉程序

如果之间干掉，听过什么方法，知道我被干掉了，通过什么方法供我后续排查问题

举一个例子，log是实时刷盘

如果收到kill信号，如果重要信息没刷进盘，怎么办（kill -9没有coredump)

tcp和udp的区别

tcp的可靠性是怎么保证的

细讲滑动窗口来进行流量控制

> 滑动窗口控制发送方的发送速率，以免接收方因数量量过大而无法及时处理，从而导致数据丢失或拥塞
>
> 流量控制：如果接收方的缓冲器满了，它会减小窗口大小，发送方必须减少发送速率
>
> 窗口大小：定义了接收方能够接收的最大数据量，发送方必须等待接收方确认已接收的数据量，直到窗口大小允许发送更多的数据

细讲拥塞控制

>流量控制是避免发送方的数据填满接收方的缓冲区，但是不知道网络中的情况
>
>在网络出现拥堵时，如果继续发送大量的数据包，可能会导致数据包时延、丢失等，这时tcp就会重传数据，但是一重传数据就会导致网络的负担更重，于是就会有更大的时延和更多的丢包，不断放大

> 慢启动	拥塞避免	超时重传	快速重传	快速恢复

怎么确认丢包

> 超时重传：发送方为每个发送的数据段设置了一个超时计数器
>
> 快速重传：当接收方收到一个失序的数据段时，它会立即发送一个对该数据段的重复确认，当发送方就收到三个重复的确认，就会任务丢失了数据段，并立即重传该数据段，而不需要等待超时计时器到期
>
> 序列号检测：tcp使用序列号来确保数据的顺序和完整性
>
> 拥塞控制

除了定时器还有其他机制吗

> 1. 定时器+ack确认
> 2. 快速重传（会重传未接收到的报文之后所有的报文）

tcp的粘包问题

你读到的所谓的长度，可能读出来是错误的数据，你怎么保证

> 校验和：在数据包的总长度字段之后，可以添加一个校验和字段，接收方在读取总长度字段后，可以计算收到的数据的校验和，并与发送方提供的校验和进行比较，以验证数据的完整性
>
> 特定的分隔符
>
> 固定长度

那你觉得在游戏业务中tcp和udp该怎么选择

io多路复用

> 指使用一个线程，监控多个`sokcet`的时间。能够资源复用，防止创建过多的线程导致的上下文开销
>
> 1. select:将已连接的`socket`都放到一个文件描述符集合，然后调用select函数将文件描述符拷贝到内核里，然内核检查是否有网络事件发生，遍历整个文件描述符集合，当检查到有事件发生后，将此`socket`标记为可读或者可写，然后将整个文件描述符拷贝到用户态，然后用户态还需要通过遍历的方法找到可读或可写的`socket`，然后再对其进行处理（select关注的描述符有上限为1024）
>
> 2. poll：poll也是使用线性结构存储要关注的`socket`集合，因此也需要遍历文件描述符集合找到可读或可写的`socket`，而且也需要在用户态与内核态之间拷贝文件描述符集合（但是poll关注的文件描述符没有上线）
>
> 3. epoll：epoll在内核中使用红黑树来追踪待检测的文件描述符，通过`epoll_ctl`把需要监控的`socket`加入内核中的红黑树，减少了内核和用户空间之间大量的数据拷贝和内存分配
>
>    epoll使用事件驱动的机制，内核维护了一个链表来记录就绪事件，当某个`socket`有事件发生时，通过回调函数内核会将其加入到这个就绪列表，当用户调用`epoll_wait`函数函数时，只会返回有事件发生的文件描述符的个数，不需要轮询遍历整个集合

讲一下epoll的回调是怎么用的

水平触发和边缘触发

muduo选择的什么

仔细讲水平触发里的buffer是什么

> input buffer：TcpConnection 会从 socket 读取数据，然后写入 input buffer（其实这一步是用 Buffer::readFd() 完成的）；客户代码从 input buffer 读取数据。
> output buffer：客户代码会把数据写入 output buffer（其实这一步是用 TcpConnection::send() 完成的）；TcpConnection 从 output buffer 读取数据并写入 socket。
>
> 客户代码从 input 读，往 output 写。TcpConnection 的读写正好相反。

muduo为什么选择水平触发，为什么不选择边沿触发

> 实现简单：**水平触发**模式下，只要文件描述符上有数据可读或空间可写，事件就会持续触发，直到数据被完全处理。因此，使用水平触发的代码逻辑相对简单，开发者不需要额外处理事件可能丢失的情况。**边沿触发**模式下，事件仅在状态变化时触发，也就是说，一旦数据到达或空间可写时触发一次，如果未能处理完，则需要开发者自己循环处理直至数据全部读完或者写完。这种方式代码复杂度较高，容易出现问题，如错过事件、处理不当等。
>
> 避免饥饿问题：在LT模式下，如果一个套接字一直有数据到来，`epoll_wait`会持续通知应用程序有可读事件，保证了公平性，其他套接字也能得到处理。而在ET模式下，如果一个套接字一直保持就绪状态，可能会导致其他套接字得不到处理，出现饥饿的情况。不会因为某个连接上的数据量过大而影响其他连接处理消息。
>
> 不会丢失数据或消息，容错性更好：在LT模式下，即使应用程序没有立即处理就绪事件，下一次`epoll_wait`仍然会返回相同的就绪事件，确保不会错过事件通知。这样在应用程序的处理逻辑出现延迟时，仍然能够正常处理就绪事件。

muduo了解怎么样？讲一下EventLoop的结构

> EventLoop起到一个驱动循环的功能，Poller负责从事件监听器上获取监听结果，Channel类将fd及其相关属性封装，并将fd及其感兴趣事件和发生的事件以及不同事件对应的回调函数封装在一起，这样在各个模块中传递更加方便。接着被EventLoop调用。
>
> 主线程也有一个线程在跑EventLoop对象的loop()函数，在这个函数内关注服务端的socketfd用来接收新的客户端socketfd连接。
>
> 将这个新的socketfd连接放到各个线程中并运行线程的EventLoop对象的loop()来关注已连接socketfd的可读可写事件。
>
> 所以EventLoop在网络库中的作用基本就是来**关注fd事件**并**执行回调函数**的

聊天服务器用了redis做中间件，详细讲一下怎么实现的

> Redis发布订阅机制是一种消息通信模式：发送者（publish）发送消息，订阅者（subscribe)接收消息
>
> Redis客户端可以订阅任意数量的通道。当有新消息通过publish命令发送给通道时，这个消息就会被发送给订阅它的客户端

> 启动订阅者代码，它会等待并监听 `my_channel` 频道的消息。
>
> 启动发布者代码，它会向 `my_channel` 频道发布一条消息。

1. 用什么结构存储的
2. 如果多读问题怎么办？
3. 序列化格式，json和protobuf
4. json序列化和反序列怎么实现的
5. json和protobuf序列化和反序列化开销
6. 平时玩游戏多么
7. 反问
8. 