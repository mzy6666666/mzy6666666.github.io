---
title: 米哈游服务器开发相关
date: 2024-07-25 17:03:28
tags: 面试
categories:
    面试
password: mzy666
abstract: 有东西被加密了, 请输入密码查看.
message: 您好, 这里需要密码.
wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试.
wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.
---


为什么服务器程序要用主线程做io，这样不是限制了主线程完成其他就绪事件的速度吗    



 Mutable和volatile关键字（没答上来...）      

虚函数及其实现      

Map multi_map unordered_map的区别      

 红黑树和AVL树的区别，为什么不用AVL树       

 给定一个无序数组，要求打乱它们的顺序，使得每个元素在每个位置的概率相等-->洗牌算法

C++八股文，多态虚函数 

函数默认参数位置，重载的时候如果多的那个形参是默认参数，调用的时候没有那个实参会发生什么？ 

队列和栈的实际应用  

DFS和BFS概念以及实际应用  

求解最短路径 

讲一讲熟悉的排序算法，排序算法中哪些是稳定的，哪些是不稳定的



堆排序复杂度，为什么是O(nlogn)

> **建堆（Heapify）**：
>
> - 将一个无序数组转化为一个堆结构（通常是最大堆或最小堆）。
> - 自底向上的建堆过程：每次从最后一个非叶节点开始，依次向上对每个节点执行堆调整（Heapify）。
> - 对于每个节点的堆调整操作，时间复杂度为 O(log⁡n)O(log n)O(logn)。
> - 由于建堆过程只需遍历每个节点一次，且每次堆调整操作的平均时间复杂度比 O(log⁡n)O(log n)O(logn) 小（大约为常数时间），所以建堆过程的总时间复杂度为 O(n)O(n)O(n)。
>
> **删除堆顶元素**：
>
> - 在排序过程中，每次删除堆顶元素（最大堆中的最大元素或最小堆中的最小元素），并将堆的最后一个元素移动到堆顶，再执行堆调整操作。
> - 每次删除堆顶元素的操作需要 O(log⁡n)O(log n)O(logn) 的时间来维护堆的性质。

1、写题： 

写一个split的函数，将一个string用逗号分隔开的各个部分切分，返回一个vector<int>，自己考虑异常输入，编写测试样例，如：-1111,1,0 ；    313413,  34324,,,,,+12432 等。 

  2、上面那道题我没有考虑字符串转成INT之后溢出的问题，面试官问了一下该如何判断溢出，如何处理，讲了思路，问了INT范围及补码表示的问题； 

  3、两个无符号数相加如何判断溢出； 

  4、写代码： 

  判断当前机器是大端还是小端； 

  5、智力题： 

  25匹马五个赛道比出前三的问题 

  6、系统设计： 

  排行榜排出前100应该怎么做？ 

  很多不同场景的方案： 

  （1)、提供前100； 

  （2）、每小时刷新，实时刷新； 

  （3）、不同战力值数值范围，如果范围很大怎么做，范围比较小怎么做。 

写代码部分： 

  1、单例模式，当时忘了剑指offer上的写法，用了锁，写的有点问题； 

  2、写一个栈，提供getMax和getMin，复杂度为O(1)。我用了两个空间为n的辅助栈。可以优化吗，讲了一些优化思路。 

  3、在第二个问题基础上，问了如果要提供栈中的中位数，如何实现？ 

  开始问问题： 

  1、map和unordered_map的优缺点，适用于什么场景？ 

  2、TCP和UDP区别，用在什么场景。 

  3、建立一个服务端需要哪些操作，我讲了常用的那些api。 

  4、time_wait的用处？答了防止服务端没收到确认，误关闭了客户端新开的socket。  问：只有这个吗？不知道其他的了。 

> 1. **确保数据包传输完成**：
>    - TIME_WAIT状态确保即使在数据传输结束后，发送方也能接收到可能因为网络延迟而迟到的FIN或ACK数据包。
> 2. **避免连接混淆**：
>    - 每个TCP连接由四元组（源IP、源端口、目的IP、目的端口）唯一标识。TIME_WAIT状态可以防止新的连接被错误地认为是尚未完全终止的旧连接。
> 3. **实现TCP全双工连接的优雅关闭**：
>    - TCP连接是全双工的，意味着数据可以在两个方向上独立传输。TIME_WAIT确保双方都完成了数据传输和确认。
> 4. **防止重复数据干扰**：
>    - 在网络中，可能会有重复的数据包在传输过程中被延迟。TIME_WAIT状态确保这些重复的数据包在新连接开始前已经被丢弃。
> 5. **满足2MSL（最大报文段生存时间）要求**：
>    - TIME_WAIT状态持续的时间是2MSL，这是一个TCP实现定义的最大生存时间。这个时间足够长，以确保所有重复的数据包都被网络丢弃。
> 6. **避免资源泄露**：
>    - 在TIME_WAIT状态下，TCP栈会保持连接的状态信息，直到2MSL时间结束。这可以防止资源泄露，例如避免IP地址和端口号的快速耗尽。
> 7. **为可能的重传提供足够的时间**：
>    - 如果在连接关闭过程中有数据包丢失，需要重传，TIME_WAIT状态提供了足够的时间窗口来完成这些重传。
> 8. **确保连接的可靠性**：
>    - TIME_WAIT状态是TCP可靠性保证的一部分，确保即使在网络条件不佳的情况下，连接的关闭也是可靠的。

  5、创建一个守护进程来监听服务进程的异常状态，比如假死。我答了如何创建守护进程，后面的没实践过，不太懂要答什么。 

  6、操作系统，进程通信，多线程同步控制等； 

  7、IO多路复用，select和epoll，ET和LT。 

  8、熟悉哪些数据库吗？没怎么用过。 

  聊天： 

  1、玩过游戏吗？除了米哈游之外的游戏 

  2、有哪些offer？有游戏公司的offer吗？为什么投米哈游 

  反问： 

  这个游戏开发是服务端还是客户端？

UDP 和 TCP 的区别，都适合什么场景：在游戏中使用KCP协议比较多。

引申了一下HTTP 的状态码：1~5开头各是什么作用

用HTTP可以实现主动推送的功能吗，为什么不使用HTTP而是使用 websocket

1. 问C++相关背景（米哈游的服务器开发那边应该C++比较多），我表示很少用C++
2. 请简单介绍一下快速排序，说一下时间复杂度；平均复杂度O(nlogn)是如何算出来的
3. 算法设计：有N个数，求其中前K个数(TopK)，说一下时间复杂度，O(nlogk)如何计算的
4. 算法设计：有N+1个数，这些数大小是1-N，只有一个数出现两边，请找出这个数

 这里我说了三个办法：bitmap;哈希表;把出现过的数对应的下标位置的数取反，最后只有一个位置的数是正的；

5. 算法设计：简述一下Dijkstra算法，该算法能否处理负权值边的情况？如果希望能处理负权边，该怎么办？
6. 有什么算法可以检测出图中的环？

 我说了个拓扑排序，但这个应该是只能检测有向图的，但面试官没追问我无向图的情况

7. 说一下python，python中的numpy数组和python中的列表有什么区别，这里是因为我在简历里写了我用过这些库
8. 机器学习你用的什么库？Keras是上层的库，下边的是实现是什么(我用的是TensorFlow)
9. 说一下python里的装饰器
10. 你知道printf怎么实现的吗？（完全不知道。。。）
11. DNS基于什么协议？为什么要采用UDP协议？
12. TCP连接结束时的TIME_WAIT状态有什么用
13. HTTPS基于的SSL连接是如何结束的？（）
14. Redis中的跳表是实现什么数据结构的(ZSET)？具体是如何实现的
15. Redis里哈希表重哈希策略是怎么样的？

 这里我说我不了解，但知道Java里的Hashmap的重哈希实现，面试官就让我说了Java里的，我也顺便说了下go里的map实现

16. Docker里的容器和镜像分别是什么？

> ### 镜像（Image）
>
> 1. **定义**：Docker 镜像是一个只读的模板，其中包含了运行一个容器所需的所有内容。它包括代码、运行时、库、环境变量和配置文件。
> 2. **用途**：镜像用于创建容器，是容器运行的蓝图。
> 3. **层次结构**：镜像通常由一系列层组成，每一层代表 Dockerfile 中的一个指令。这种层次化的设计使得镜像更小、更高效。
> 4. **存储**：镜像存储在 Docker Hub 或其他容器镜像仓库中，可以通过网络下载。
> 5. **不可变性**：一旦镜像被创建，它就是不可变的。这意味着镜像中的文件和设置不能被修改，除非创建一个新的镜像。
>
> ### 容器（Container）
>
> 1. **定义**：Docker 容器是一个运行实例，它从镜像启动，并可以运行、停止、移动和删除。
> 2. **用途**：容器用于运行和隔离应用。每个容器都是独立的，拥有自己的文件系统、网络设置、进程空间等。
> 3. **可写性**：与镜像不同，容器是可写的。在容器中所做的任何更改都只存在于容器的生命周期内，除非这些更改被提交到一个新的镜像。
> 4. **隔离性**：容器提供了操作系统级别的隔离，使得应用可以在不同的环境中一致地运行，而不受宿主机环境的影响。
> 5. **可移植性**：容器可以在任何安装了 Docker 的主机上运行，无论其底层操作系统如何。
> 6. **生命周期**：容器的生命周期是短暂的。当容器被删除时，其中的数据也会被删除，除非这些数据被持久化到宿主机或外部存储中。
>
> ### 容器和镜像的关系
>
> - **创建容器**：容器从镜像启动，每次启动容器时，Docker 会从镜像创建一个新容器实例。
> - **修改容器**：在容器运行期间，可以对其进行修改，如安装软件、修改文件等。这些修改只影响当前容器实例。
> - **持久化数据**：如果需要持久化容器中的数据，可以使用 Docker 的卷（Volumes）或绑定宿主机的目录到容器中。
> - **更新镜像**：如果需要更新容器的镜像，可以创建一个新的镜像，并重新启动容器，使用新的镜像。

16. Go里的调度模型有GMP的概念，解释一下，并说一下go的调度过程

 这个要说的话真的有点长，这里我说了一半就被打断了，可能面试官也不是特别了解？要么就是我说错了被面试官发现了。。。

18. Go的调度模型里为什么要有P？
19. 你为什么想做游戏服务器开发呢？你对游戏怎么看？

1.虚函数要学扎实，比如为什么要有虚函数这个东西。
2.数据结构的底层实现原理
3.堆栈的区别（为什么要有堆栈？为什么对象要用new的，不直接用对象？）
4.进程空间是怎么样的？分配内存的过程？
5.进程间的通信方式，以及会应用在哪些地方？
6.进程切换跟线程切换，为什么要切换，切换要保存什么东西等。
7.多路复用的函数的原理（select，poll，epoll）
8.数据库的一些基本知识（我数据库真的是瓦坎达的瓦）

#### 一面第二轮(50min)：

1. 自我介绍 
2. c++的面向对象特性（封装、继承、多态） 
3. 用c语言模拟实现简单的c++中的多态 
4. 在堆上创建内存，malloc是怎么实现的 
5. 指针和引用的区别 
6. map和unordered_map的区别 
7. 如果自定义一个类型来作为unordered_map的key值，但编译器编译未通过，什么原因？ 
8. TCP和UDP的区别，TCP中“连接”的含义 
9. 如果两方已经建立了TCP连接，突然中间经过的一些物理链路断开了一段时间又恢复了，这时候两方的连接是否还存在？情况比较多，这个问题想回答好需要多思考一下。 
10. UDP的使用场景，在UDP的基础上设计实现TCP的功能 
11. 简历上项目相关 
12. 智能指针的介绍。实现一个简单的shared_ptr 
13. 反问环节 

#### 二面(45min)：

这里录屏设置出错了，只录到了自己的声音，没有捕获到面试官的声音，整理的就很粗糙。

1. 自我介绍 
2. 项目相关 
3. 函数调用过程 
4. 程序中各种类型变量存储的位置 
5. 多态 
6. delete this的各种执行情况（分别在类的构造函数中，在类的析构函数中，在类的普通函数中执行会发生什么情况，当这个对象被定义在栈上、在堆上又会发生什么情况） 
7. 任意删除大/小顶堆中的某一个节点后，（注意不是顶点），如何调整使之恢复 
8. TCP、UDP相关 
9. 虚拟内存/物理内存/如何转换等等 
10. 普通函数调用/系统调用/进程线程等等 
11. 反问环节

#### 一面（1h20min）：

1. 平时玩什么游戏 
2. 多态的原理 
3. 有继承关系的父子类中，父类的析构函数需要设置为虚函数的原因 
4. 几种智能指针，分别如何实现的 
5. shared_ptr的线程安全性分析 
6. 关于weak_ptr和shared_ptr的关系，weak_ptr是如何实现的（源码层面）。这一块可以看我的一篇很详细的博客：面试知识点详细解读之智能指针 | LYL's Blog [https://yuanlehome.github.io/DVejmy5owOXx5WKk/](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fyuanlehome.github.io%2FDVejmy5owOXx5WKk%2F) 
7. vector的内存分配方式，默认内存分配器allocator的实现 
8. 内存池的作用，存在的意义（内存碎片和系统调用效率） 
9. 在vector中删除满足指定条件的值的方式，迭代器失效的场景 

> 1. **插入操作**：
>    - 在 `vector` 中使用 `insert` 插入元素可能导致插入点后的所有迭代器失效。
> 2. **删除操作**：
>    - 使用 `erase` 删除元素可能导致被删除元素之后的所有迭代器失效。
> 3. **重新分配**：
>    - 当 `vector` 需要重新分配内存来容纳更多元素时（例如，当容量不足以容纳新元素时），所有迭代器都会失效。
> 4. **容量改变**：
>    - 使用 `reserve` 或 `shrink_to_fit` 改变 `vector` 的容量可能导致迭代器失效。
> 5. **赋值操作**：
>    - 使用 `operator=` 赋值给另一个 `vector` 会导致原有 `vector` 中的所有迭代器失效。

1. 数组和链表的区别，删除操作 
2. 单链表中如何O(1)删除其中一个节点 
3. 队列和栈的区别，底层实现 
4. 二叉搜索书和红黑树的区别，红黑树是如何保持平衡的 
5. 哈希表的作用，时空复杂度，如何解决冲突 
6. 有一群人，对他们的年龄进行排序，如何设计排序方案 
7. 进程和线程区别，在linux中的实现 
8. fork系统调用之后的过程，返回值 
9. 线程同步的方式有哪些 

> 信号量、互斥锁、自旋锁、条件变量、读写锁、原子操作

1. 孤儿进程和僵尸进程 

> ### 孤儿进程（Orphan Process）：
>
> 1. **定义**：孤儿进程是指其父进程在子进程终止之前退出的进程。当一个父进程退出时，其所有子进程都会被系统收养，即它们的父进程ID会被设置为1（在大多数系统中，1号进程是init进程）。
>
> 2. 特点
>
>    ：
>
>    - 孤儿进程最终会被init进程接管。
>    - init进程会等待这些孤儿进程结束，并读取它们的退出状态。
>    - 孤儿进程不会永远停留在系统中，因为init进程会处理它们的终止状态。
>
> ### 僵尸进程（Zombie Process）：
>
> 1. **定义**：僵尸进程是已经执行完成，但是其父进程还没有读取其退出状态的进程。在类Unix系统中，当一个子进程结束时，它的进程描述符、状态和资源使用统计信息会被保留，直到父进程调用`wait()`或`waitpid()`系统调用读取这些信息。
>
> 2. 特点
>
>    ：
>
>    - 僵尸进程占用系统进程表，但是不占用其他资源。
>    - 它们会显示在ps命令的输出中，状态标记为"Z"。
>    - 僵尸进程不能被杀死，因为它们已经没有执行代码了，它们的存在只是为了让父进程能够读取它们的退出状态。
>    - 如果父进程没有适当的处理，僵尸进程会一直存在，直到系统重启。
>
> ### 区别：
>
> - **状态**：孤儿进程是父进程已经退出的子进程，而僵尸进程是已经终止但父进程尚未读取其退出状态的子进程。
> - **存在时间**：孤儿进程最终会被系统处理，不会长期存在；僵尸进程则可能长时间存在，直到父进程读取其状态或系统重启。
> - **处理方式**：孤儿进程由init进程接管并处理，僵尸进程需要父进程显式地调用`wait()`系列函数来处理。
>
> ### 避免僵尸进程：
>
> - **及时处理**：父进程应该在子进程结束后尽快调用`wait()`或`waitpid()`来读取子进程的退出状态。
> - **使用信号处理**：可以为子进程设置信号处理函数，当子进程结束时，通过信号通知父进程。
> - **使用非阻塞调用**：在某些情况下，可以使用非阻塞的系统调用来避免僵尸进程的产生。

1. linux系统上cpu的占用率达到了100%，如何排查问题 
2. TCP和UDP的区别，应用场景 
3. 以游戏为场景来分析什么时候用TCP什么时候用UDP 

> - **TCP** 用于处理登录、注册、好友列表、聊天等需要可靠传输和较少延迟的功能。
> - **UDP** 用于处理游戏内实时数据传输，如玩家位置、射击、跳跃等，这些操作对实时性要求高，但可以容忍一定程度的数据丢失。

1. IO多路复用，select和epoll的区别 
2. 做一个编程题，用了两种思路方法
     
3. 反问环节 

#### 二面（50min）：

直接做了三道编程题

1. 二叉树的序列化和反序列化 
2. 三个线程交替打印A、B、C 
3. 最长无重复子串 
4. 反问环节

（1) 有个问题很有意思，快排为什么叫快排？平均时间复杂度和堆排差不多吧？什么时候用堆排，什么时候用快排，为什么快排就快了呢
（2) 游戏场景题：fps游戏里一个子弹打中一个人，这个过程如何设计

**米哈游一面**  

**进程和线程的区别，共享了什么资源**  

> 进程是操作系统资源分配的最小单位，线程是c pu调度的最小单位
>
> 进程拥有独立的内存空间和系统资源，而线程共享所属线程的内存空间和资源
>
> 创建进程的开销比线程大
>
> 共享：全局变量和静态变量、代码段、堆内存、文件描述符、IO上下文、信号量

   **进程有几种状态？线程呢？**  

> 新建、就绪、运行、阻塞

   **Cpu大小端**  

   **线程之间同步方式（互斥量，读写锁，信号量，自旋锁，条件变量）**  

   **乐观锁和悲观锁**  

**红黑树的时间复杂度，怎么执行插入删除操作**  

   **7.** **数组和链表的区别**  

**死锁，四个必要条件**  

> 互斥条件
>
> 不可剥夺
>
> 持有和等待条件
>
> 循环等待条件
>
> 

   **9.** **如何解决死锁，线程也会死锁吗？**  

> 使用锁的顺序：都按相同的顺序获取锁
>
> 银行家算法（避免死锁）
>
> 使用条件变量

   **10.** **Linux cpu100%出现的原因，怎么解决**  

> ```shell
> # 1. 使用top找到最耗cpu的进程pid
> top
> # 2. 找到最耗cpu的线程tid
> top -Hp pid
> # 3. 将线程pid转换为十六进制
> printf "%x\n" [tid]  将tid转换为十六进制
> # 4. 查看线程的堆栈信息
> jstack [pid] | grep -A 10 [tid的十六进制]  打印堆栈信息
> # 5. 根据栈顶信息分析问题
> ```

> ```shell
> # 看那个线程跑慢了
> top -Hp <pid>
> 
> # 在超级用户下，追踪到进程，追踪到之后，进程会停下正在运行的所有线程
> gdb ./my_program <pid>
> 
> # 查看当前进程起来的所有线程
> info thread
> 
> # 切到占用高的线程
> thread <thread_idx>
> 
> # 查看调用栈
> bt
> ```

   **11.** **Linux软链接、硬链接。怎么拷贝的**  

> 硬链接是对文件inode（索引节点）的引用。创建硬链接后，文件的inode会增加一个引用计数。只有当引用计数变为0时，文件才会被真正删除。硬链接具有以下特点：
>
> - 不能跨文件系统创建。
> - 可以指向目录。
> - 删除硬链接不会影响原文件。
>
> 软链接是一种指向另一个文件或目录的快捷方式，类似于Windows系统中的快捷方式。软链接实际上是一个特殊的文件，其中包含了它所指向的文件或目录的路径。软链接具有以下特点：
>
> - 可以跨文件系统创建。
> - 不能指向目录（除非使用特殊的命令）。
> - 删除软链接不会影响原文件。
> - 如果原文件被移动或删除，软链接会变成死链接（dangling link）。
>
> **拷贝时创建硬链接而不是复制文件**：
>
> ```
> cp -l source_file destination_file
> ```

   **12.** **tcp和udp区别（tcp可靠，udp实时性更好）**  



   **13.** **Udp一定是不可靠的吗？（有可靠udp）**  

   **14.** **Sctp协议**  

   **15.** **http和https协议区别**  

   **16.** **Socket编程，阻塞和非阻塞的区别？Accept函数，如果非阻塞，这个函数是怎么处理的？返回值是什么？返回的信号具体是什么？(wouldblock)**  

   **17.** **TCP的nagle算法**  

   **18.** **数据库的索引是什么**  

   **19.** **Mysql底层索引是怎么实现的？（存储引擎-B+树）**  

> MySQL的底层索引实现主要依赖于B+树数据结构，这种结构特别适合用于数据库索引，因为它可以有效地减少查找数据时所需的磁盘I/O次数。

   **20.** **Binlog是什么**  

> Binlog（Binary Log）是MySQL数据库中的一种日志文件，主要用于记录数据库的所有修改操作，包括数据的插入、更新、删除等操作。Binlog是二进制格式的日志文件
>
> Binlog是MySQL复制功能的基础。在主从复制架构中，从服务器通过读取主服务器的Binlog来获取数据变更，从而实现数据同步。
>
> **数据恢复**：在发生故障时，可以使用Binlog进行数据恢复。通过回放Binlog文件中的操作，可以恢复到故障发生前的状态。
>
> **非阻塞性**：Binlog的写入操作是异步的，不会阻塞正常的数据库操作，因此对数据库性能的影响较小。

   **21.** **Redis持久化**  

> rdb和aof实现

   **22.** **实习工作里组件化思想是什么？实习做了什么工作**  

   **23.** **为什么想要找服务器开发？**  

> 选择服务器开发作为职业道路的原因可能有很多，这里列举一些常见的动机：
>
> 1. **技术挑战**：服务器开发涉及到解决复杂的技术问题，对于喜欢挑战和不断学习新技术的人来说，这是一个吸引人的领域。
> 2. **高需求**：随着互联网和移动应用的普及，对服务器和后端系统的需求不断增长，这意味着有很多就业机会。
> 3. **高薪酬**：由于服务器开发是一个需要专业知识和技能的领域，因此通常能提供较高的薪酬。
> 4. **职业发展**：服务器开发提供了多样化的职业发展路径，包括成为高级开发人员、架构师、技术经理等。

   \--------------  

​    米哈游二面   

       1. 为什么要做服务器开发   

> 服务器开发是构建和维护后端服务的过程，这些服务是任何应用程序、网站或系统的核心组成部分。以下是为什么要进行服务器开发的原因：
>
> 1. **提供响应服务**：
>    - 服务器是处理客户端请求并返回响应的中心点。开发服务器确保了服务的可用性和响应性。
> 2. **数据处理和存储**：
>    - 服务器负责处理和存储大量数据，包括用户信息、交易数据等，需要开发合适的逻辑来管理这些数据。
> 3. **业务逻辑实现**：
>    - 服务器端是实现业务逻辑的地方，这些逻辑对于应用程序的功能至关重要。
> 4. **安全性**：
>    - 服务器开发包括实现安全措施，如用户认证、数据加密和防止网络攻击。
> 5. **可扩展性**：
>    - 随着用户数量的增加，服务器需要能够扩展以处理更高的负载，这需要在开发时就考虑进去。
> 6. **性能优化**：
>    - 服务器开发需要优化性能，确保快速响应和高效资源使用。
> 7. **多用户支持**：
>    - 服务器必须能够同时支持成千上万的用户，这需要良好的架构和资源管理。
> 8. **系统集成**：
>    - 在企业环境中，服务器开发常常涉及与现有系统的集成，如数据库、支付网关和其他第三方服务。
> 9. **高可用性和容错性**：
>    - 开发高可用性的服务器，确保服务即使在部分系统失败的情况下也能继续运行。
> 10. **自动化和运维支持**：
>     - 服务器开发还包括开发自动化脚本和工具，以简化部署、监控和维护工作。
> 11. **满足特定需求**：
>     - 定制开发服务器可以满足特定业务或技术需求，提供竞争优势。
> 12. **新技术的应用**：
>     - 服务器开发允许尝试和集成新技术，如云计算、容器化、微服务架构等。

2. 游戏服务器一般要什么工作方式？要提供哪些模块、哪些功能   

> ### 工作方式
>
> 1. **客户端-服务器架构**：
>    - 游戏服务器通常采用客户端-服务器架构，客户端负责玩家的输入和显示，服务器负责游戏逻辑和数据存储。
> 2. **实时性**：
>    - 对于多人在线游戏，实时性非常重要。服务器需要快速响应玩家的操作并将结果传递给其他玩家。
> 3. **高并发**：
>    - 游戏服务器需要能够处理大量同时在线的玩家，这要求服务器具备高并发处理能力。
> 4. **负载均衡**：
>    - 通过负载均衡，将玩家请求分配到多个服务器，以确保系统稳定和性能高效。
>
> ### 主要模块和功能
>
> 1. **连接管理**：
>    - 负责处理玩家的连接和断开，包括认证和会话管理。
> 2. **游戏逻辑**：
>    - 包含游戏的核心逻辑和规则，例如物理引擎、战斗系统、任务系统等。
> 3. **状态同步**：
>    - 确保所有玩家在游戏中的状态一致，包括位置、动作和状态变化等。
> 4. **数据库管理**：
>    - 存储玩家数据、游戏数据和日志，通常使用关系数据库或NoSQL数据库。
> 5. **聊天系统**：
>    - 提供玩家之间的即时通信功能，包括私人聊天、公共聊天和群组聊天等。
> 6. **匹配系统**：
>    - 为玩家寻找合适的对手或队友，确保游戏的公平性和竞技性。
> 7. **排行榜和成就系统**：
>    - 记录玩家的成绩和成就，提供排行榜和奖励系统，增加游戏的竞争性和趣味性。
> 8. **安全性**：
>    - 防止作弊和攻击，保护玩家数据和服务器的安全。
> 9. **更新和补丁**：
>    - 提供游戏更新和补丁分发，确保玩家能够获得最新的游戏内容和修复已知问题。
> 10. **监控和运维**：
>     - 实时监控服务器性能和状态，快速响应和处理故障，确保服务器的稳定运行。
>
> ### 具体实现
>
> #### 连接管理
>
> - **身份验证**：使用OAuth或其他认证机制验证玩家身份。
> - **会话管理**：跟踪每个玩家的会话信息，管理连接的生命周期。
>
> #### 游戏逻辑
>
> - **物理引擎**：处理游戏中的物理计算，如碰撞检测和运动。
> - **AI系统**：控制非玩家角色（NPC）的行为和响应。
> - **任务系统**：管理游戏中的任务和事件，包括任务发布、更新和完成。
>
> #### 状态同步
>
> - **帧同步**：在固定时间间隔内同步所有玩家的状态，常用于竞技游戏。
> - **状态快照**：周期性地发送完整的游戏状态快照，确保所有玩家的状态一致。
>
> #### 数据库管理
>
> - **关系数据库**：存储结构化数据，如玩家账号信息和交易记录。
> - **NoSQL数据库**：存储非结构化数据，如游戏内物品和动态数据。
>
> #### 安全性
>
> - **加密**：使用SSL/TLS加密玩家与服务器之间的通信。
> - **反作弊系统**：监控和检测异常行为，防止作弊和非法操作。
>
> #### 监控和运维
>
> - **日志记录**：记录玩家行为和系统事件，用于分析和调试。
> - **告警系统**：在系统出现异常时发送告警通知，及时处理问题。

> 游戏服务器是游戏架构中的关键部分，负责处理游戏逻辑、玩家数据存储、网络通信等核心功能。以下是游戏服务器通常采用的工作方式、需要提供的模块和功能：
>
> ### 工作方式：
>
> 1. **多线程或异步处理**：为了应对大量并发连接和请求，游戏服务器通常采用多线程或异步I/O模型来提高性能和响应速度。
> 2. **分布式架构**：大型多人在线游戏（MMO）可能采用分布式服务器架构，将不同的服务和负载分散到多个物理或虚拟服务器上。
> 3. **微服务架构**：一些游戏服务器可能采用微服务架构，将不同的游戏功能和服务拆分成独立的服务单元，便于扩展和维护。
>
> ### 需要提供的模块：
>
> 1. **网络通信模块**：处理客户端与服务器之间的数据传输，包括协议设计、数据序列化和反序列化等。
> 2. **账号管理模块**：负责玩家账号的创建、登录、验证等功能。
> 3. **角色管理系统**：处理玩家角色的创建、属性管理、存档和加载等。
> 4. **世界管理模块**：管理游戏世界的状态，包括地图信息、NPC、环境对象等。
> 5. **战斗系统**：处理游戏中的战斗逻辑、技能释放、伤害计算等。
> 6. **任务和成就系统**：管理玩家的任务接受、完成和奖励发放，以及成就的解锁。
> 7. **交易系统**：允许玩家之间或与NPC进行物品交易。
> 8. **社交系统**：包括好友列表、公会、聊天室等功能。
> 9. **数据库管理模块**：负责玩家数据、游戏状态等数据的存储和管理。
> 10. **负载均衡模块**：在分布式架构中，负责请求的分发和服务器负载的均衡。
>
> ### 需要提供的功能：
>
> 1. **高可用性**：确保服务器稳定运行，减少宕机时间。
> 2. **扩展性**：能够根据玩家数量和游戏需求进行水平或垂直扩展。
> 3. **安全性**：保护玩家数据安全，防止作弊和黑客攻击。
> 4. **数据一致性**：确保在分布式环境中数据的一致性和完整性。
> 5. **容错性**：在部分组件失败时，仍能继续提供服务。
> 6. **监控和日志**：实时监控服务器状态，记录日志以便于问题追踪和性能优化。
> 7. **备份和恢复**：定期备份数据并在需要时能够快速恢复。
> 8. **更新和维护**：支持游戏内容的更新和服务器的维护操作，影响最小化。
> 9. **多平台支持**：支持不同平台（PC、移动设备、控制台等）的客户端连接。

游戏服务器与网络服务器的区别

> ### 1. **功能和目的**：
>
> - **游戏服务器**：专门用于处理游戏相关的逻辑和数据，如玩家角色管理、游戏状态同步、战斗计算、任务管理等。它们通常需要处理复杂的游戏逻辑和实时数据交互。
> - **网络服务器**：更广泛地用于提供网络服务，如文件存储、内容分发、数据库服务、网站托管等。它们的功能更侧重于数据存储、传输和访问控制。
>
> ### 2. **性能要求**：
>
> - **游戏服务器**：需要极高的实时性和低延迟，因为玩家在游戏中的体验高度依赖于响应速度。它们通常需要优化以支持高并发和高频率的数据交互。
> - **网络服务器**：虽然也需要良好的性能，但对实时性的要求可能不如游戏服务器严格。它们更侧重于高吞吐量和数据访问效率。
>
> ### 3. **架构设计**：
>
> - **游戏服务器**：可能采用分布式架构，以便处理大量玩家和复杂的游戏世界。它们可能需要复杂的状态同步和一致性机制。
> - **网络服务器**：架构可能更简单，侧重于数据的存储和检索。它们可能采用负载均衡和冗余设计来提高可用性和可靠性。
>
> ### 4. **安全性**：
>
> - **游戏服务器**：需要特别关注防止作弊、黑客攻击和数据篡改。它们可能需要复杂的安全机制和实时监控系统。
> - **网络服务器**：虽然也需要关注安全性，但重点可能更在于数据保护和访问控制，防止未授权访问和数据泄露。
>
> ### 5. **用户体验**：
>
> - **游戏服务器**：直接影响玩家的游戏体验，因此需要特别关注用户体验，如游戏流畅性、公平性和互动性。
> - **网络服务器**：用户体验可能更侧重于数据访问的便捷性和服务的稳定性。
>
> ### 6. **数据类型和处理**：
>
> - **游戏服务器**：处理的数据类型通常包括玩家状态、游戏逻辑、实时交互数据等，这些数据通常具有高度的动态性和复杂性。
> - **网络服务器**：处理的数据类型可能更广泛，包括静态内容、数据库记录、文件等，这些数据通常更静态和结构化。
>
> ### 7. **更新和维护**：
>
> - **游戏服务器**：可能需要频繁更新以添加新内容、修复bug或调整游戏平衡。这些更新需要精心设计以最小化对玩家体验的影响。
> - **网络服务器**：更新可能更侧重于系统维护和功能扩展，通常对用户的影响较小。
>
> ### 8. **成本和资源**：
>
> - **游戏服务器**：可能需要更多的计算资源和带宽，尤其是在高峰时段，以支持大量玩家的并发访问。
> - **网络服务器**：资源需求可能更均匀，但也需要考虑数据存储和备份的成本。
>
> 

3. Tcp有什么功能？可靠udp还有什么问题？   

> TCP（传输控制协议）和UDP（用户数据报协议）是两种常用的网络协议，它们在OSI模型的传输层中工作，用于在网络中的设备之间传输数据。以下是它们各自的功能和存在的问题：
>
> ### TCP的功能：
>
> 1. **可靠性**：TCP提供可靠的数据传输服务，确保数据包正确、按顺序地到达目的地。
> 2. **数据校验**：TCP通过序列号和确认应答机制来校验数据，确保数据的完整性。
> 3. **拥塞控制**：TCP内置拥塞控制算法，能够在网络拥塞时调整数据传输速率。
> 4. **流量控制**：TCP使用滑动窗口机制来控制发送速率，防止接收方被大量数据淹没。
> 5. **全双工通信**：TCP允许双向通信，即发送和接收可以同时进行。
> 6. **面向连接**：TCP在数据传输前需要建立连接，这确保了通信双方的可达性。
> 7. **有序传输**：TCP保证数据包按发送顺序到达接收方。
>
> ### TCP存在的问题：
>
> 1. **性能开销**：由于TCP的可靠性和控制机制，它在性能上有一定的开销。
> 2. **延迟**：TCP的确认和重传机制可能导致延迟，特别是在高延迟网络中。
> 3. **资源消耗**：TCP的连接需要维护状态信息，这可能导致资源消耗。
> 4. **不适合流媒体**：由于TCP的特性，它不适合需要低延迟和高吞吐量的应用，如流媒体。
>
> ### UDP的功能：
>
> 1. **无连接**：UDP是无连接的协议，数据传输前不需要建立连接。
> 2. **简单高效**：UDP协议简单，头部开销小，适合快速传输。
> 3. **广播和多播**：UDP支持广播和多播传输，适用于视频会议和在线游戏等场景。
> 4. **实时性**：UDP的低延迟特性使其适合实时应用，如VoIP和在线游戏。
>
> ### UDP存在的问题：
>
> 1. **不可靠性**：UDP不保证数据包的可靠传输，可能会发生数据丢失。
> 2. **无序传输**：UDP不保证数据包的顺序，接收方可能需要额外的逻辑来重新排序。
> 3. **无拥塞控制**：UDP没有内置的拥塞控制机制，可能导致网络拥塞。
> 4. **无流量控制**：UDP不提供流量控制，可能会导致接收方处理不过来。
> 5. **安全性问题**：UDP容易受到网络攻击，如DDoS攻击，因为它不进行连接验证。

    4. Udp无连接，哪么怎么知道消息是从哪个用户发过来的？（应该从连接方面来答）   

> 1. **端口号**：每个UDP数据报都包含源端口和目的端口号。即使没有建立传统意义上的“连接”，端口号也可以用来区分不同用户的通信流。发送者在数据报中设置源端口号，接收者可以通过这个端口号识别哪个应用或服务发送了数据。
> 2. **IP地址**：每个UDP数据报还包含源IP地址和目的IP地址。结合端口号，接收者可以知道数据报是从哪个IP地址和端口号组合的发送者那里接收到的。
> 3. **初始握手信息**：在某些应用中，尽管使用UDP，但在数据传输开始前，客户端和服务器之间可能会有一个初始的握手过程，用于交换必要的识别信息，如用户名或会话ID。
> 4. **应用层协议**：应用可以定义自己的协议，在UDP数据报中包含足够的信息来识别发送者。例如，可以在每个UDP数据报的头部添加特定的格式，用于存放用户标识。
> 5. **状态信息**：虽然UDP是无连接的，但接收方可以在其内部维护状态信息，记录与不同源IP地址和端口号相关联的用户信息。
> 6. **NAT穿透技术**：在使用NAT（网络地址转换）的网络中，可以通过STUN（Session Traversal Utilities for NAT）或类似的NAT穿透技术来获取用户在NAT后的公网IP地址和端口号。
> 7. **加密和认证**：在安全敏感的应用中，可以使用加密和认证机制来确保消息的发送者是经过验证的。例如，可以使用TLS（传输层安全性）来为UDP通信提供安全层。
> 8. **会话标识**：在UDP通信中，可以在应用层生成唯一的会话标识符，并在每个数据报中包含这个标识符，以识别和关联特定的通信会话。

​    5. Redis分布式锁？项目里怎么用的？   

​    6. Redis,场景，买东西，一个操作涉及到两个用户，如何保证操作的一致性？   

       7. Redis事务不能保证原子性的原因？   

> **命令队列的执行**：在Redis事务中，所有在`MULTI`和`EXEC`之间发出的命令只是被排队，直到`EXEC`命令执行时才实际执行。这意味着在命令被实际执行之前，如果客户端连接断开或发生其他错误，事务不会被执行。
>
> **单个命令的失败**：在`EXEC`命令执行时，所有命令会按照顺序依次执行，即使某个命令失败了，其他命令仍然会继续执行。这与关系型数据库的事务不同，在关系型数据库中，如果事务中的某个操作失败，整个事务会回滚。
>
> **乐观锁检查失败**：如果在事务执行过程中，使用了`WATCH`命令来监控某些键的变化，且在`EXEC`执行前这些键被其他客户端修改，`EXEC`会返回`nil`表示事务失败。但这个失败并不会自动重试或回滚，只是简单地返回失败信息，事务中的命令不会被执行。
>
> **无回滚机制**：Redis事务没有提供回滚机制。即使某个命令在事务执行过程中失败，之前已经执行的命令也不会被撤销。
>
> **Redis事务提供了一种保证一组命令的顺序执行的机制，但它无法保证所有命令的原子性和一致性，这就是Redis事务不能保证原子性的主要原因。**

       8. Redis事务底层怎么实现的？

> **事务开始 (`MULTI`)**:
>
> - 当客户端发送`MULTI`命令时，Redis会将客户端标记为处于事务状态，同时为该客户端创建一个命令队列，用于存储接下来发送的所有命令。
>
> **命令入队**:
>
> - 在事务状态下，客户端发送的所有命令不会立即执行，而是被依次放入该命令队列中。
>
> **监视机制 (`WATCH`)**:
>
> - `WATCH`命令用于实现乐观锁。当客户端发送`WATCH`命令时，Redis会将指定的键添加到客户端的监视列表中。如果在执行`EXEC`命令之前，任何被监视的键发生了变化（被其他客户端修改），事务将被取消。
> - Redis通过维护一个键的版本号（每次键被修改时，版本号递增）来实现这个监视机制。
>
> **事务执行 (`EXEC`)**:
>
> - 当客户端发送`EXEC`命令时，Redis首先检查所有被监视的键是否发生了变化。如果任何一个被监视的键在事务期间被其他客户端修改过，`EXEC`将返回`nil`，事务中所有的命令都不会被执行。
> - 如果所有被监视的键都没有变化，Redis将依次执行命令队列中的所有命令。每个命令会按照队列顺序逐一执行，执行结果会作为一个数组返回给客户端。
>
> **命令的执行**:
>
> - 在`EXEC`过程中，每个命令会依次从队列中取出并执行。Redis事务的命令执行是原子的，即每个命令要么完全执行，要么不执行，但事务整体不保证原子性。
>
> **事务取消 (`DISCARD`)**:
>
> - 如果在事务执行过程中，客户端发送了`DISCARD`命令，Redis将清空该客户端的命令队列并退出事务状态。
>
>  

​    9. Redis用了什么架构？（主从模式+哨兵）   

​    10. Redis为效率那么高   

​    11. Redis多路复用epoll的et,lt是什么？为什么xx更好？   

​    12. 怎么设计一个排行榜？（redis zset跳表）

1.自我介绍
2.三次握手

> 首先，客户端会选择一个初始序列号并发送一个SYN包给服务器，请求建立连接；SYN标志位置1，表示请求同步
>
> 然后，服务器在接收到客户端的SYN包后，如果同意建立连接，会发送一个SYN-ACK包作为响应。同时服务器也会选择自己的初始序列号，表示已经接收到客户端的请求并确认
>
> 然后，客户端在接收到服务器的SYN-ACK包后，会发送一个ACK包作为最终响应。这个包，ACK被置为1，表示客户端已经收到服务器的同步请求并确认。
>
> 这个过程完成后，tcp连接就成功建立，数据可以开始在两个实体之间传输。

三次握手的目的

>1. 同步连接双方的序列号和确认号，确保双方的接收和发送能力是正常的，从而建立一个可靠的通信通道。
>2. 防止重复旧的连接初始化请求突然又传送到服务端（例如：网络阻塞），因而产生错误连接的功能。因为每个连接请求都包含一个唯一的序列号，如果连接请求在网络中延迟了，服务端可以通过**序列号判断出这个连接请求是否超时**。

TCP三次握手过程中，如果服务器没有响应，客户端会如何处理？

> 1. 超时重传：客户端在发送SYN包后会启动一个定时器，如果在定时器到期之前没有收到服务器的SYN-ACK响应，客户端就会任务这个包在传输过程中丢失或者损坏，然后客户端会重新发送SYN包
> 2. 连续重传

3.socket编程理解

> socket编程是一种网络编程技术，它允许应用程序通过TCP/IP协议进行通信。socket是网络通信的端点，提供了一种抽象的方式来发送和接收数据。
>
> 创建socket、绑定ip和端口号、监听socket、连接、数据传输、关闭

4.七层模型有哪些

> 物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

10.进程之间怎么通信

> 管道、命名管道、匿名管道、信号、信号量、消息队列、共享内存、套接字

11.什么场景用进程？什么场景用线程？

> 使用进程的场景：
>
> 1. 资源隔离：当需要严格隔离应用程序的资源和数据时，使用进程可以提供更好的安全性和稳定性
> 2. 容错率：进程间的错误不会影响到其他进程，因此适合容错高的系统（nginx）
> 3. 多任务处理：对于需要同时运行多个独立任务的系统，使用进程可以避免任务间的相互干扰（播放音乐、网页浏览）
> 4. 不同的操作系统：当需要在不同的操作系统上运行应用程序时，可以使用进程来封装和隔离不同系统之间的差异（Docker）
>
> 使用线程的场景：
>
> 1. 资源共享：当需要在多个任务之间共享资源（内存、文件句柄）时，使用线程可以减少资源复制的开销(gui组件)
> 2. 并行处理：对于需要并行处理的任务，如图形处理、数据分析等，使用线程可以提高处理速度
> 3. 需要频繁切换的任务：对于需要频繁切换的任务，如用户界面和后台处理，使用线程能减少上下文切换的开销（视频播放器在播放视频时使用多个线程，一个用于解码，另一个用于渲染）
> 4. 任务依赖性：当任务之前存在依赖关系，需要同步执行时，使用线程可以方便地进行任务调度和同步
>
> - **进程**：适合需要严格隔离、独立运行、高容错性的场景。
> - **线程**：适合需要资源共享、并行处理、快速响应、任务依赖性高的场景。

12.对计算机硬件的理解

> （处理器）cpu：执行指令和处理数据
>
> 内存：存储当前正在使用的数据和程序
>
> 存储设备：固态硬盘和机械硬盘，用于长期存储数据
>
> GPU：用于处理图形和视频渲染的任务
>
> 网口：运行计算机连接到网络，进行数据传输

1.怎么查看Linux文件类型？以及755是什么文件权限？

> ```
> ls -l
> ```
>
> 755 rwxr_xr_x
>
> - 文件权限也可以通过数字来表示，每个数字对应一个权限集合：
>   - 4 表示可读（r）
>   - 2 表示可写（w）
>   - 1 表示可执行（x）
> - 权限数字是这些数字的总和。例如，755表示：
>   - 所有者（第1位数字7）：可读（4）+ 可写（2）+ 可执行（1）= 7
>   - 组用户（第2位数字5）：可读（4）+ 可执行（1）= 5
>   - 其他用户（第3位数字5）：同组用户

1.还有一些bash脚本的问题
13.怎么在Linux系统查看计算机的硬件信息

> ```
> lscpu  # 查看cpu架构
> free -m # 显示虚拟内存信息
> df -h 	# 显示文件系统的磁盘使用情况
> lspci   # 显示显卡的PCI信息
> ```
>
> 

14.ssh端口号是多少

> | ssh       | 20   |
> | --------- | ---- |
> | http      | 80   |
> | https     | 443  |
> | ftp       | 21   |
> | telnet    | 23   |
> | mysql     | 3306 |
> | redis     | 6379 |
> | zookeeper | 2181 |

15.常见数据结构有哪些
16.对于栈的理解以及在项目哪里用到过？

> 栈的特点是后进先出，只运行在栈顶进行添加和删除，适用于递归算法和回溯算法
>
> 应用场景：函数调用、括号匹配

开始挖项目
29.对于运维和开发的理解

> 运维：
>
> 1. 负责系统维护：保持系统的日常运行，包括监控、更新和故障排除和修复
> 2. 基础设备管理：管理服务器、网络设备和存储系统的配置和部署
> 3. 性能优化：监控系统性能，进行调优
> 4. 安全保障：实施安全策略，保护系统免受攻击，包括防火墙、入侵检测和数据加密
> 5. 备份与恢复：制定和执行数据备份计划，确保在数据丢失或系统故障时可以快速恢复
> 6. 自动化：通过自动化工具和脚本提高运维效率，减少人为错误
>
> 开发
>
> 1. 需求分析：与客户和业务团队合作，理解需求并转换为技术规格
> 2. 设计：设计软件架构、数据库模式和用户界面
> 3. 编码：编写代码实习软件功能
> 4. 测试：进行单元测试、集成测试和系统测试
> 5. 版本控制：使用版本控制系统管理代码变更和发布
> 6. 文档编写：编写技术文档和用户手册，帮助用户和维护人员理解软件
>
> 测试开发工程师的理解
>
> 1. 自动化测试：负责设计和实习自动化测试框架，提高测试过程的效率和可重复性
> 2. 测试工具开发：开发定制的测试工具和标本，以满足特定的测试需求
> 3. 性能测试：开发性能奢侈的工具
> 4. 持续集成：与开发团队合作，将自动化测试集成到持续集成/持续部署（CI/CD）流程中。

反问：
30:米哈游的游戏基本上都是一部分pve一部分pvp，相较于纯pvp类型的游戏，在服务端的要求是不是会有些不一样？

> 1. **服务端架构**：
>    - PVE和PVP游戏可能需要不同的服务端架构。PVE可能更侧重于任务、剧情和探索，而PVP可能需要更复杂的匹配系统和实时对战处理。
> 2. **数据一致性**：
>    - PVE内容可能更侧重于单人或小队玩家的体验，数据一致性要求可能较低。而PVP游戏需要确保所有玩家看到的游戏状态是一致的，以避免作弊和不公平的优势。
> 3. **网络延迟和同步**：
>    - PVP游戏通常对网络延迟和数据同步有更高的要求，因为玩家间的互动是实时的。服务端需要优化网络代码，减少延迟，确保所有玩家的体验公平。
> 4. **负载均衡**：
>    - PVP游戏可能需要更复杂的负载均衡策略，因为玩家可能集中在特定的对战模式或时段。服务端需要能够处理高并发和快速扩展。
> 5. **匹配系统**：
>    - PVP游戏需要一个有效的匹配系统，将玩家根据技能、等级或装备进行匹配，以确保对战的公平性。
> 6. **作弊检测**：
>    - PVP游戏更容易受到作弊的影响，服务端需要有更强的作弊检测和预防机制。
> 7. **资源管理**：
>    - PVE游戏可能更侧重于资源的收集和使用，而PVP游戏可能更侧重于玩家间的交互和战斗。
> 8. **更新和维护**：
>    - PVP游戏可能需要更频繁的更新和维护，以平衡角色、武器和游戏机制，确保公平竞争。
> 9. **社交功能**：
>    - 虽然PVE和PVP游戏都可能包含社交元素，但PVP游戏可能更侧重于玩家间的互动，如聊天、组队和好友系统。

面试官问我还有没有对于米哈游运维技术和技术栈的问题？我说没

> 您能介绍一下米哈游在运维方面使用的主要技术栈和工具吗？
>
> 在米哈游，运维团队通常面临哪些类型的技术挑战？
>
> 运维团队是如何结构化的？团队成员之间如何协作？

面试官问我还有没有对于米哈游游戏服务器开发技术和技术栈的问题？

> 当面试官询问你是否对米哈游游戏服务器开发技术和技术栈有进一步的问题时，这是一个展示你对职位热情和专业好奇心的机会。以下是一些建议性的回答和问题，你可以根据自己的兴趣和了解程度进行调整：
>
> 1. **技术栈询问**：
>    - “您能否详细介绍一下米哈游游戏服务器开发使用的主要技术栈？”
> 2. **架构设计**：
>    - “在米哈游，游戏服务器的架构设计是如何考虑可扩展性和高可用性的？”
> 3. **网络通信**：
>    - “针对游戏中的实时互动特性，网络通信是如何优化以减少延迟和提高稳定性的？”
> 4. **数据处理**：
>    - “游戏服务器在处理大量并发数据时，采用了哪些策略来保证数据处理的效率和准确性？”
> 5. **安全措施**：
>    - “在保护玩家数据和防止作弊方面，米哈游采取了哪些安全措施？”
> 6. **微服务架构**：
>    - “米哈游是否采用微服务架构来开发游戏服务器？如果是的话，这如何帮助团队提高开发效率和维护性？”
> 7. **云服务和容器化**：
>    - “米哈游在游戏服务器开发中是否使用了云服务和容器化技术？这些技术如何影响开发和部署流程？”
> 8. **持续集成和持续部署（CI/CD）**：
>    - “您能否介绍一下米哈游的CI/CD流程，以及它如何帮助加快开发周期和提高软件质量？”
> 9. **性能监控和优化**：
>    - “游戏服务器如何进行性能监控，以及在发现问题时如何快速响应和优化？”
> 10. **新技术和趋势**：
>     - “米哈游在游戏服务器开发中是否关注或采用新兴技术？例如，AI、机器学习或区块链等。”
> 11. **团队合作**：
>     - “在游戏服务器开发团队中，不同角色之间是如何协作的？例如，开发人员、测试人员和运维人员。”
> 12. **职业发展**：
>     - “对于加入米哈游的游戏服务器开发团队，公司提供哪些职业发展和技能提升的机会？”