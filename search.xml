<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker入门</title>
    <url>/2024/05/17/Docker%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="Docker入门教程"><a href="#Docker入门教程" class="headerlink" title="Docker入门教程"></a>Docker入门教程</h1><h2 id="Ubuntu-Docker安装步骤"><a href="#Ubuntu-Docker安装步骤" class="headerlink" title="Ubuntu Docker安装步骤"></a>Ubuntu Docker安装步骤</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">卸载旧的源</span></span><br><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新软件包</span></span><br><span class="line">sudo apt update </span><br><span class="line">sudo apt upgrade</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装docker依赖</span></span><br><span class="line">sudo apt install apt-transport-https ca-certificates curl software-properties-common gnupg lsb-release</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加Docker官方GPG密钥</span></span><br><span class="line">curl -fsSL curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加Docker软件源</span></span><br><span class="line">sudo add-apt-repository &quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装Docker</span></span><br><span class="line">apt-get install docker-ce docker-ce-cli containerd.io</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Docker版本</span></span><br><span class="line">sudo docker version</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动Docker</span></span><br><span class="line">sudo systemctl start docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Docker运行状态</span></span><br><span class="line">sudo systemctl status docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">允许非Root用户执行docker 命令</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.添加docker用户组</span></span><br><span class="line">sudo groupadd docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.将当前用户添加到用户组</span></span><br><span class="line">sudo usermod -aG docker $USER</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.使权限生效</span></span><br><span class="line">newgrp docker </span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">卸载docker</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.卸载依赖</span></span><br><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.删除资源</span></span><br><span class="line">rm -rf /var/lib/docker   # docker的默认工作路径</span><br></pre></td></tr></table></figure>

<h2 id="配置阿里云镜像加速"><a href="#配置阿里云镜像加速" class="headerlink" title="配置阿里云镜像加速"></a>配置阿里云镜像加速</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://wgg82qbx.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h2 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h2><p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/image-20240516121849040.png"  alt="image-20240516121849040"></p>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/61f881d798344b0e8ded77eb5181bc9e.png"  alt="在这里插入图片描述"></p>
<h3 id="Docker容器生命周期管理"><a href="#Docker容器生命周期管理" class="headerlink" title="Docker容器生命周期管理"></a>Docker容器生命周期管理</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建并运行容器</span></span><br><span class="line">docker run --name 容器名 镜像名</span><br><span class="line">-d #后台启动</span><br><span class="line">-it /bin/bash   #以交互方式</span><br><span class="line">-p 宿主机端口：容器端口  # 暴露端口</span><br><span class="line">ctrl + p + q 切换终端</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建但不启动容器</span></span><br><span class="line">docker create --name 容器名 镜像名:tag</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动一个或多个已经被停止的容器</span></span><br><span class="line">docker start  容器名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止一个运行中的容器</span></span><br><span class="line">docker stop 容器名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启容器</span></span><br><span class="line">docker restart 容器名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">杀掉一个运行中的容器</span></span><br><span class="line">docker kill 容器名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除一个或者多个容器</span></span><br><span class="line">docker rm 容器名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">暂停容器中所有的进程</span></span><br><span class="line">docker pause 容器名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">恢复容器中所有的进程</span></span><br><span class="line">docker unpause 容器名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器的终端</span></span><br><span class="line">docker exec -i -t myhello-docker /bin/bash</span><br></pre></td></tr></table></figure>

<p>不关闭容器，退回宿主机。这样的话，容器还在后台运行。</p>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/1729889-20240419153307055-1060946887.png"  alt="img"></p>
<h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出容器</span></span><br><span class="line">docker ps </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看容器中运行的进程信息</span></span><br><span class="line">docker top</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取容器日志</span></span><br><span class="line">docker logs 容器名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示容器资源的使用情况，包括：CPU、内存、网络I/O等</span></span><br><span class="line">docker stats</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从容器创建一个新的镜像</span></span><br><span class="line">docker commit -a &quot;提交的镜像作者&quot; -m &quot;提交的文字说明&quot; 容器名/容器ID 镜像名：tag</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">容器与主机之间的数据拷贝</span></span><br><span class="line">docker cp 主机路径 容器ID:路径</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查容器里文件结构的更改</span></span><br><span class="line">docker diff 容器名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看容器详细信息</span></span><br><span class="line">docker inspect 容器id</span><br></pre></td></tr></table></figure>

<h3 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</span></span><br><span class="line">docker login</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">登出一个Docker镜像仓库</span></span><br><span class="line">docker logout</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从镜像仓库中拉取或者更新指定镜像</span></span><br><span class="line">docker pull 镜像名:tag</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将本地的镜像上传到镜像仓库,要先登陆到镜像仓库</span></span><br><span class="line">docker push 镜像名:tag</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从Docker Hub查找镜像</span></span><br><span class="line">docker search 镜像名</span><br></pre></td></tr></table></figure>

<h3 id="本地镜像管理"><a href="#本地镜像管理" class="headerlink" title="本地镜像管理"></a>本地镜像管理</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出本地镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除本地镜像</span></span><br><span class="line">docker rmi 镜像名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">标记本地镜像，将其归入某一仓库</span></span><br><span class="line">docker rmi -f $(docker images -aq) # 删除全部镜像</span><br><span class="line">docker tag 镜像名:tag 用户名/仓库:tag</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 Dockerfile 创建镜像</span></span><br><span class="line">docker build -t 镜像名:tag 路径</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看指定镜像的创建历史</span></span><br><span class="line">docker history 镜像名:tag</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将指定镜像保存成 tar 归档文件</span></span><br><span class="line">docker save -o  文件名.tar  镜像名:tag</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">导入使用 docker save 命令导出的镜像</span></span><br><span class="line">docker load -i 镜像名:tag</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从归档文件中创建镜像</span></span><br><span class="line">docker import 文件名.tar</span><br></pre></td></tr></table></figure>

<h3 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示 Docker 系统信息，包括镜像和容器数</span></span><br><span class="line">docker info</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示 Docker 版本信息</span></span><br><span class="line">docker version</span><br></pre></td></tr></table></figure>

<h2 id="Docker容器数据卷"><a href="#Docker容器数据卷" class="headerlink" title="Docker容器数据卷"></a>Docker容器数据卷</h2><p><strong>什么是容器数据卷？</strong></p>
<p>容器数据卷（Container Data Volumes）是Docker管理的一种特殊类型的存储区域，它为容器提供了一种<strong>持久化数据</strong>、<strong>共享数据</strong>以及与宿主机或其他容器之间进行<strong>数据交互</strong>的有效方式。</p>
<blockquote>
<p>如果数据都在容器中，那么容器删除，数据就会丢失！MySQL的容器删除 &#x3D; 删库 &#x3D;&gt; 跑路</p>
<p>容器之间可以有一个数据共享的技术。</p>
<p>docker容器中产生的数据，同步到本地。这就是卷技术！即容器的目录挂载到Linux上。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载目录，并运行镜像进入容器，在容器内部的/home目录下创建测试文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker run -it -v 主机目录:容器目录</span></span><br><span class="line">docker run -it --name ubuntu01 -v /home/mzy/ubuntu:/home ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<p><strong>匿名挂载和具名挂载</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">匿名挂载 -v 容器目录</span></span><br><span class="line">docker run -d -P --name nginx01 -v /etc/nginx nginx</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">具名挂载(不能加路径)</span></span><br><span class="line">docker run -d -P --name nginx02 -v 具体卷名:/etc/nginx nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有卷的情况</span></span><br><span class="line">docker volume ls</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看具体卷名信息</span></span><br><span class="line">docker volume inspect 具体卷名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">没有具体路径的卷名都在`/var/lib/docker/volumes`下</span></span><br></pre></td></tr></table></figure>

<p><strong>容器间挂载</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--volumes-from 父容器</span></span><br><span class="line">docker run -it --name docker02 --volumes-from docker01 ubuntu</span><br></pre></td></tr></table></figure>

<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/image-20240517161642812.png"  alt="image-20240517161642812"></p>
<h3 id="实战：mysql同步数据"><a href="#实战：mysql同步数据" class="headerlink" title="实战：mysql同步数据"></a>实战：mysql同步数据</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取镜像</span></span><br><span class="line">docker pull mysql:5.7</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行容器，需要做数据挂载</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动mysql，需要配置密码</span></span><br><span class="line"></span><br><span class="line">-d 后台启动</span><br><span class="line">-p 端口映射</span><br><span class="line">-v 数据卷挂载</span><br><span class="line">-e 环境配置</span><br><span class="line">--name 容器名</span><br><span class="line"></span><br><span class="line">docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</span><br></pre></td></tr></table></figure>

<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/image-20240516122104731.png"  alt="image-20240516122104731"></p>
<blockquote>
<p><strong>Dockerfile</strong>是用来构建Docker镜像的文件，是由一条条构建镜像所需的指令和参数构成的脚本。</p>
<p>构建三部曲：</p>
<ol>
<li>编写Dockerfile文件</li>
<li>docker build命令创建镜像</li>
<li>docker run依赖镜像运行容器实例</li>
</ol>
</blockquote>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/image-20240516122520985.png"  alt="image-20240516122520985"></p>
<table>
<thead>
<tr>
<th><strong>指令</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>FROM</td>
<td>设置镜像使用的基础镜像</td>
</tr>
<tr>
<td>MAINTAINER</td>
<td>设置镜像的作者</td>
</tr>
<tr>
<td>RUN</td>
<td>编译镜像时运行的脚本</td>
</tr>
<tr>
<td>CMD</td>
<td>设置容器的启动命令</td>
</tr>
<tr>
<td>LABEL</td>
<td>设置镜像的标签</td>
</tr>
<tr>
<td>EXPOSE</td>
<td>设置镜像暴露的端口</td>
</tr>
<tr>
<td>ENV</td>
<td>设置容器的环境变量</td>
</tr>
<tr>
<td>ADD</td>
<td>编译镜像时复制文件到镜像中</td>
</tr>
<tr>
<td>COPY</td>
<td>编译镜像时复制文件到镜像中</td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td>设置容器的入口程序</td>
</tr>
<tr>
<td>VOLUME</td>
<td>设置容器的挂载卷</td>
</tr>
<tr>
<td>USER</td>
<td>设置运行RUN CMD ENTRYPOINT的用户名</td>
</tr>
<tr>
<td>WORKDIR</td>
<td>设置RUN CMD ENTRYPOINT COPY ADD指令的工作目录</td>
</tr>
<tr>
<td>ARG</td>
<td>设置编译镜像时加入的参数</td>
</tr>
<tr>
<td>ONBUILD</td>
<td>设置镜像的ONBUILD指令</td>
</tr>
<tr>
<td>STOPSIGNAL</td>
<td>设置容器的退出信号量</td>
</tr>
</tbody></table>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/image-20240517163715102.png"  alt="image-20240517163715102"></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">CMD：指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代</span><br><span class="line">ENTRYPOINT：指定这个容器启动的时候要运行的命令，可以追加命令</span><br></pre></td></tr></table></figure>

<p>Dockerfile里的内容：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">14</span>-alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> index.js /index.js</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> node /index.js</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建镜像</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">					镜像名：tag 	当前目录</span></span><br><span class="line">docker build -t hello-world:v1.0.0 .	</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建容器并运行容器实例</span></span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>

<h2 id="为什么Docker会比VM虚拟机快"><a href="#为什么Docker会比VM虚拟机快" class="headerlink" title="为什么Docker会比VM虚拟机快"></a>为什么Docker会比VM虚拟机快</h2><ul>
<li><p>docker有着比虚拟机更少的抽象层</p>
<blockquote>
<p>docker不需要Hypervisor（虚拟机）实现硬件资源虚拟化，运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会效率上有明显优势。</p>
</blockquote>
</li>
<li><p>docker利用的是宿主机的内核，而不需要加载操作系统OS内核</p>
<blockquote>
<p>Docker容器共享宿主机的操作系统内核，不需要像虚拟机一样每个实例都运行完整的操作系统。这使得Docker容器在启动和停止时更加轻量级和快速。</p>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Docker容器</th>
<th>虚拟机（VM）</th>
</tr>
</thead>
<tbody><tr>
<td>操作系统</td>
<td>与宿主机共享OS</td>
<td>宿主机OS上运行虚拟机OS</td>
</tr>
<tr>
<td>存储大小</td>
<td>镜像小，便于存储与传输</td>
<td>镜像庞大（vmdk,vdi 等）</td>
</tr>
<tr>
<td>运行性能</td>
<td>几乎无额外性能损失</td>
<td>操作系统额外的CPU, 内存消耗</td>
</tr>
<tr>
<td>移植性</td>
<td>轻便、灵活，适用于Linux</td>
<td>笨重，与虚拟化技术耦合度高</td>
</tr>
<tr>
<td>硬件亲和性</td>
<td>面向软件开发者</td>
<td>面向硬件运维者</td>
</tr>
<tr>
<td>部署速度</td>
<td>快速，秒级</td>
<td>较慢，10s以上</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx入门笔记</title>
    <url>/2024/06/18/Nginx%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Nginx入门教程"><a href="#Nginx入门教程" class="headerlink" title="Nginx入门教程"></a>Nginx入门教程</h1><p>Nginx是⽬前最流⾏的Web服务器</p>
<h2 id="nginx安装"><a href="#nginx安装" class="headerlink" title="nginx安装"></a>nginx安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 更新仓库信息</span></span><br><span class="line">sudo apt-get update</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 安装nginx</span></span><br><span class="line">sudo apt-get install nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3. 验证安装</span></span><br><span class="line">sudo nginx -V</span><br></pre></td></tr></table></figure>

<h2 id="nginx常用命令"><a href="#nginx常用命令" class="headerlink" title="nginx常用命令"></a>nginx常用命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx # 启动Nginx</span><br><span class="line">nginx -c filename # 指定配置⽂件</span><br><span class="line">nginx -V # 查看Nginx的版本和编译参数等信息</span><br><span class="line">nginx -t # 检查配置⽂件是否正确，也可⽤来定位配置⽂件的位置</span><br><span class="line">nginx -s quit # 优雅停⽌Nginx</span><br><span class="line">nginx -s stop # 快速停⽌Nginx</span><br><span class="line">nginx -s reload # 重新加载配置⽂件</span><br><span class="line">nginx -s reopen # 重新打开⽇志⽂件</span><br></pre></td></tr></table></figure>

<h2 id="Nginx的配置⽂件"><a href="#Nginx的配置⽂件" class="headerlink" title="Nginx的配置⽂件"></a>Nginx的配置⽂件</h2><p><code>Nginx</code>的配置⽂件是<code>nginx.conf</code> ，⼀般位于<code> /etc/nginx/nginx.conf</code> 。可以使⽤ <code>nginx -t</code> 来查看配置⽂件的位置和检查配置⽂件是否正确</p>
<h3 id="配置⽂件的结构"><a href="#配置⽂件的结构" class="headerlink" title="配置⽂件的结构"></a><strong>配置⽂件的结构</strong></h3><p><code>Nginx</code>的配置⽂件是由⼀系列的指令组成的，每个指令都是由⼀个指令名和⼀个或者多个参数组成的。指令和参数之间使⽤空格来分隔，指令以分号 ; 结尾，参数可以使⽤单引号或者双引号来包裹。配置⽂件分为以下⼏个部分：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全局块</span></span><br><span class="line"><span class="attribute">worker_processes</span> <span class="number">1</span>;</span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line"><span class="comment"># events块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line"><span class="comment"># http块</span></span><br><span class="line">	<span class="section">server</span> &#123;</span><br><span class="line">	<span class="comment"># server块</span></span><br><span class="line"> 		<span class="section">location</span> / &#123;</span><br><span class="line">		<span class="comment"># location块</span></span><br><span class="line">		 &#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>全局块</strong></p>
<blockquote>
<p>全局块是配置⽂件的第⼀个块，也是配置⽂件的主体部分，主要⽤来设置⼀些影响<code>Nginx</code>服务器整体运⾏的配置指令，主要包括配置运⾏<code>Nginx</code>服务器的⽤户（组）、允许⽣成的<code>worker process</code>数、进程PID存放路径、⽇志存放路径和类型以及配置⽂件引⼊等。</p>
</blockquote>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定运⾏Nginx服务器的⽤户，只能在全局块配置</span></span><br><span class="line"><span class="comment"># 将user指令注释掉，或者配置成nobody的话所有⽤户都可以运⾏</span></span><br><span class="line"><span class="comment"># user [user] [group]</span></span><br><span class="line"><span class="comment"># user nobody nobody;</span></span><br><span class="line"><span class="attribute">user</span> nginx;</span><br><span class="line"><span class="comment"># 指定⽣成的worker进程的数量，也可使⽤⾃动模式，只能在全局块配置</span></span><br><span class="line"><span class="attribute">worker_processes</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment"># 错误⽇志存放路径和类型</span></span><br><span class="line"><span class="attribute">error_log</span> /var/log/nginx/<span class="literal">error</span>.log <span class="literal">warn</span>;</span><br><span class="line"><span class="comment"># 进程PID存放路径</span></span><br><span class="line"><span class="attribute">pid</span> /var/run/nginx.pid;</span><br></pre></td></tr></table></figure>

<p> <strong>events块</strong></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="comment"># 指定使⽤哪种⽹络IO模型，只能在events块中进⾏配置</span></span><br><span class="line">    <span class="comment"># use epoll</span></span><br><span class="line">    <span class="comment"># 每个worker process允许的最⼤连接数</span></span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>http块</strong></p>
<blockquote>
<p>http块是配置⽂件的主要部分，包括http全局块和server块</p>
</blockquote>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="comment"># nginx 可以使⽤include指令引⼊其他配置⽂件</span></span><br><span class="line">     <span class="attribute">include</span> /etc/nginx/mime.types;</span><br><span class="line">    <span class="comment"># 默认类型，如果请求的URL没有包含⽂件类型，会使⽤默认类型</span></span><br><span class="line">     <span class="attribute">default_type</span> application/octet-stream; <span class="comment"># 默认类型</span></span><br><span class="line">    <span class="comment"># 开启⾼效⽂件传输模式</span></span><br><span class="line">     <span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="comment"># 连接超时时间</span></span><br><span class="line">     <span class="attribute">keepalive_timeout</span> <span class="number">65</span>;</span><br><span class="line">    <span class="comment"># access_log ⽇志存放路径和类型</span></span><br><span class="line">    <span class="comment"># 格式为：access_log &lt;path&gt; [format [buffer=size] [gzip[=level]]</span></span><br><span class="line">    [flush=time] [if=condition]];</span><br><span class="line">     <span class="attribute">access_log</span> /var/log/nginx/access.log main;</span><br><span class="line">    <span class="comment"># 定义⽇志格式</span></span><br><span class="line">     <span class="attribute">log_format</span> main <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>]</span></span><br><span class="line"><span class="string">    &quot;<span class="variable">$request</span>&quot;&#x27;</span></span><br><span class="line">    <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">	<span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;</span><br><span class="line">    <span class="comment"># 设置sendfile最⼤传输⽚段⼤⼩，默认为0，表示不限制</span></span><br><span class="line">    <span class="comment"># sendfile_max_chunk 1m;</span></span><br><span class="line">    <span class="comment"># 每个连接的请求次数</span></span><br><span class="line">    <span class="comment"># keepalive_requests 100;</span></span><br><span class="line">    <span class="comment"># keepalive超时时间</span></span><br><span class="line">     <span class="attribute">keepalive_timeout</span> <span class="number">65</span>;</span><br><span class="line">    <span class="comment"># 开启gzip压缩</span></span><br><span class="line">    <span class="comment"># gzip on;</span></span><br><span class="line">    <span class="comment"># 开启gzip压缩的最⼩⽂件⼤⼩</span></span><br><span class="line">    <span class="comment"># gzip_min_length 1k;</span></span><br><span class="line">    <span class="comment"># gzip压缩级别，1-9，级别越⾼压缩率越⾼，但是消耗CPU资源也越多</span></span><br><span class="line">    <span class="comment"># gzip_comp_level 2;</span></span><br><span class="line">    <span class="comment"># gzip压缩⽂件类型</span></span><br><span class="line">    <span class="comment"># gzip_types text/plain application/javascript application/xjavascript text/css application/xml text/javascript application/x-httpdphp image/jpeg image/gif image/png;</span></span><br><span class="line">    <span class="comment"># upstream指令⽤于定义⼀组服务器，⼀般⽤来配置反向代理和负载均衡</span></span><br><span class="line">     <span class="section">upstream</span> www.example.com &#123;</span><br><span class="line">    <span class="comment"># ip_hash指令⽤于设置负载均衡的⽅式，ip_hash表示使⽤客户端的IP进⾏hash，</span></span><br><span class="line">    这样可以保证同⼀个客户端的请求每次都会分配到同⼀个服务器，解决了session共享的问题</span><br><span class="line">     ip_hash;</span><br><span class="line">    <span class="comment"># weight ⽤于设置权重，权重越⾼被分配到的⼏率越⼤</span></span><br><span class="line">     <span class="attribute">server</span> <span class="number">192.168.50.11:80</span> weight=<span class="number">3</span>;</span><br><span class="line">     <span class="attribute">server</span> <span class="number">192.168.50.12:80</span>;</span><br><span class="line">     <span class="attribute">server</span> <span class="number">192.168.50.13:80</span>;</span><br><span class="line"> &#125;</span><br><span class="line">     <span class="section">server</span> &#123;</span><br><span class="line">   	 <span class="comment"># 参考server块的配置</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>server块</strong></p>
<blockquote>
<p>server块是配置虚拟主机的，⼀个http块可以包含多个server块，每个server块就是⼀个虚拟主机。</p>
</blockquote>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="comment"># 监听IP和端⼝</span></span><br><span class="line">    <span class="comment"># listen的格式为：</span></span><br><span class="line">    <span class="comment"># listen [ip]:port [default_server] [ssl] [http2] [spdy] [proxy_protocol] [setfib=number] 		[fastopen=number] [backlog=number];</span></span><br><span class="line">    <span class="comment"># listen指令⾮常灵活，可以指定多个IP和端⼝，也可以使⽤通配符</span></span><br><span class="line">    <span class="comment"># 下⾯是⼏个实际的例⼦：</span></span><br><span class="line">    <span class="comment"># listen 127.0.0.1:80; # 监听来⾃127.0.0.1的80端⼝的请求</span></span><br><span class="line">    <span class="comment"># listen 80; # 监听来⾃所有IP的80端⼝的请求</span></span><br><span class="line">    <span class="comment"># listen *:80; # 监听来⾃所有IP的80端⼝的请求，同上</span></span><br><span class="line">    <span class="comment"># listen 127.0.0.1; # 监听来⾃来⾃127.0.0.1的80端⼝，默认端⼝为80</span></span><br><span class="line">     <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="comment"># server_name ⽤来指定虚拟主机的域名，可以使⽤精确匹配、通配符匹配和正则匹配等⽅式</span></span><br><span class="line">    <span class="comment"># server_name example.org www.example.org; # 精确匹配</span></span><br><span class="line">    <span class="comment"># server_name *.example.org; # 通配符匹配</span></span><br><span class="line">    <span class="comment"># server_name ~^www\d+\.example\.net$; # 正则匹配</span></span><br><span class="line">     <span class="attribute">server_name</span> localhost;</span><br><span class="line">    <span class="comment"># location块⽤来配置请求的路由，⼀个server块可以包含多个location块，每个</span></span><br><span class="line">    <span class="section">location</span>块就是⼀个请求路由</span><br><span class="line">    <span class="comment"># location块的格式是：</span></span><br><span class="line">    <span class="comment"># location [=|~|~*|^~] /uri/ &#123; ... &#125;</span></span><br><span class="line">    <span class="comment"># = 表示精确匹配，只有完全匹配上才能⽣效</span></span><br><span class="line">        <span class="comment"># ~ 表示区分⼤⼩写的正则匹配</span></span><br><span class="line">    <span class="comment"># ~* 表示不区分⼤⼩写的正则匹配</span></span><br><span class="line">    <span class="comment"># ^~ 表示普通字符匹配，如果匹配成功，则不再匹配其他location</span></span><br><span class="line">    <span class="comment"># /uri/ 表示请求的URI，可以是字符串，也可以是正则表达式</span></span><br><span class="line">    <span class="comment"># &#123; ... &#125; 表示location块的配置内容</span></span><br><span class="line">     <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="comment"># root指令⽤于指定请求的根⽬录，可以是绝对路径，也可以是相对路径</span></span><br><span class="line">         <span class="attribute">root</span> /usr/share/nginx/html; <span class="comment"># 根⽬录</span></span><br><span class="line">        <span class="comment"># index指令⽤于指定默认⽂件，如果请求的是⽬录，则会在⽬录下查找默认⽂件</span></span><br><span class="line">         <span class="attribute">index</span> index.html index.htm; <span class="comment"># 默认⽂件</span></span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment"># 下⾯是⼀些location的示例：</span></span><br><span class="line">     <span class="section">location</span> = / &#123; <span class="comment"># 精确匹配请求</span></span><br><span class="line">         <span class="attribute">root</span> /usr/share/nginx/html;</span><br><span class="line">         <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="section">location</span><span class="regexp"> ^~</span> /images/ &#123; <span class="comment"># 匹配以/images/开头的请求</span></span><br><span class="line">   		<span class="attribute">root</span> /usr/share/nginx/html;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="section">location</span> <span class="regexp">~* \.(gif|jpg|jpeg)$</span> &#123; <span class="comment"># 匹配以gif、jpg或者jpeg结尾的请求</span></span><br><span class="line">   		<span class="attribute">root</span> /usr/share/nginx/html;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="section">location</span> !<span class="regexp">~ \.(gif|jpg|jpeg)$</span> &#123; <span class="comment"># 不匹配以gif、jpg或者jpeg结尾的请求</span></span><br><span class="line">     	<span class="attribute">root</span> /usr/share/nginx/html;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="section">location</span> !<span class="regexp">~* \.(gif|jpg|jpeg)$</span> &#123; <span class="comment"># 不匹配以gif、jpg或者jpeg结尾的请求</span></span><br><span class="line">     	<span class="attribute">root</span> /usr/share/nginx/html;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment"># error_page ⽤于指定错误⻚⾯，可以指定多个，按照优先级从⾼到低依次查找</span></span><br><span class="line">     <span class="attribute">error_page</span> <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /50x.html; <span class="comment"># 错误⻚⾯</span></span><br><span class="line">     <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">     	<span class="attribute">root</span> /usr/share/nginx/html;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<embed src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/Nginx%E7%AC%94%E8%AE%B0.pdf" type="application/pdf" width="100%" height="600px" />

]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Raft算法</title>
    <url>/2024/06/11/Raft%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Raft算法"><a href="#Raft算法" class="headerlink" title="Raft算法"></a>Raft算法</h1><p>Raft 算法是一种可靠且易于理解的共识算法，适用于构建分布式系统。它通过领导者选举、日志复制和安全性保证来实现一致性。</p>
<blockquote>
<p>Raft 算法中有三个角色：领导者（leader）、候选人（candidate）、跟随者（follower）。</p>
<ul>
<li><strong>领导者（leader）</strong>：负责处理客户端请求，并将日志复制到其他节点。</li>
<li><strong>候选人（candidate）</strong>：是在选举过程中的临时角色，它负责发起选举并尝试成为新的领导者。</li>
<li><strong>跟随者（follower）</strong>：只是被动地接受来自领导者的指令，并将日志复制到自己的日志中。</li>
</ul>
</blockquote>
<h2 id="领导者选举"><a href="#领导者选举" class="headerlink" title="领导者选举"></a>领导者选举</h2><ul>
<li><code>raft</code>算法，当集群节点发现领导者故障下线，健康节点会重新选举，选出新的领导选举，由它去协调分布式系统操作。</li>
<li><code>redis</code>哨兵选举策略与<code>raft</code>算法大同小异，都是通过（多轮）选举，选出票数超过半数（法定人数可配）的候选人作为领导选举。</li>
<li>而 <code>redis</code>（哨兵）集群节点有三种角色：<code>master/slave/sentinel</code>，<code>sentinel</code>主要负责检测<code>master</code>故障，一旦发现<code>master</code>客观下线，<code>sentinel</code>马上进入 投票选举 环节，从多个<code>sentinel</code>节点中选出领导选举，由它去执行<code> master</code>的故障转移。</li>
</ul>
<blockquote>
<p>master 主观下线 –&gt; master 客观下线 –&gt; 投票选举 leader –&gt; leader 执行故障转移</p>
</blockquote>
<h2 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h2><ul>
<li>raft 算法的数据复制是 <code>强一致性</code>，领导者接收客户端的请求，将日志复制到其他节点，并确保被复制节点上的数据日志顺序一致。</li>
<li>当半数以上的其他节点成功接收日志，领导者才会确认该条日志提交成功，并修改其它节点上的日志状态为提交成功，通过这样的方式保证集群的数据一致性。</li>
<li><code>redis</code>的数据复制是 <code>最终一致</code>，master 负责接收客户端的请求，将数据写入内存后，异步复制数据到 slave。</li>
<li><code>slave</code>初始或断线重连<code>master</code>，发现数据不一致后，会根据 <code>slave</code>当前的数据偏移量或<code>master</code>节点 ID，向<code>master</code>实现增量同步或者全量同步。</li>
<li>如果<code>slave</code>正常链接<code>master</code>，<code>master</code>数据发生变化会正常发送给对应<code>slave</code>，但不需要半数以上的<code>slave</code>节点确认接收才确认数据同步成功。</li>
<li><code>redis</code>是高性能服务，它需要在保证性能的前提下进行数据复制，因此数据的 <code>最终一致</code> &lt; <code>强一致</code>。</li>
</ul>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><ul>
<li><p><code>raft</code>算法的日志复制是强一致，安全性明显要比<code>redis</code>要好。</p>
</li>
<li><p><code>raft</code>算法的领导选举，需要确保日志的<code>term</code>和日志的<code>index</code>最优的健康的节点当选领导者。</p>
</li>
<li><p><code>redis</code>数据复制是最终一致，<code>master</code>设置数据积压缓冲区和数据偏移量，与<code>slave</code>的数据量进行对比，进行数据复制实现最终一致。</p>
</li>
<li><p><code>redis master</code>故障下线后，<code>redis</code>哨兵重新选举，选出新的哨兵领导者。哨兵领导者在下线 <code>master </code>的 <code>slave </code>节点中筛选出最优（网络链接正常，优先级低，数据偏移量最大）的<code>slave</code>将其晋升为<code>master</code>。</p>
</li>
</ul>
<h2 id="redis的高可用性"><a href="#redis的高可用性" class="headerlink" title="redis的高可用性"></a>redis的高可用性</h2><p><code>redis</code>用复制来解决可靠性，一份数据做多份冗余。但是，当<code>master</code>节点因为某种原因下线，还必须有一种机制能让<code>slave</code>节点自动地转化成<code>master</code>节点，对外提供写服务，保证系统的高可用性。<code>redis</code>的<code>sentinel</code>就是这样的一种机制。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Raft</tag>
      </tags>
  </entry>
  <entry>
    <title>Reactor/Proactor模式</title>
    <url>/2024/06/06/Reactor-Proactor%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="服务器的演变"><a href="#服务器的演变" class="headerlink" title="服务器的演变"></a>服务器的演变</h1><ol>
<li>为每个连接创建一个进程&#x2F;线程（不断的创建和销毁进程&#x2F;线程，带来很大的性能开销，造成资源浪费）</li>
<li>创建线程池（无法高效的处理多个连接业务，一个线程处理多个连接的业务时，线程在处理某个连接的<code>read</code>操作（默认是阻塞的）时，如果一直没有数据可读，就会阻塞，线程就无法处理其他业务）</li>
<li>将阻塞IO改为非阻塞IO (线程会不断的轮询调用<code>read</code>来判断是否有数据，轮询是消耗CPU的，而且随着一个线程要处理的连接越多，轮询的效率就会越低)</li>
<li>I&#x2F;O多路复用（不需要轮询，用系统调用函数监听关心的事件，注册回调，没有事情发生时，会阻塞在这个系统调用，而不是像线程池那样轮询调用<code>read</code>）</li>
<li>使用<code>Reactor/Proactor</code>模式：将IO事件与业务分离，解耦</li>
</ol>
<h2 id="阻塞IO和非阻塞IO"><a href="#阻塞IO和非阻塞IO" class="headerlink" title="阻塞IO和非阻塞IO"></a>阻塞IO和非阻塞IO</h2><ul>
<li>针对阻塞 I&#x2F;O 执行的系统调用可能因为无法立即完成而被操作系统挂起，直到等待的事件发生为止。可能被阻塞的系统调用为 <strong>accept</strong>、<strong>send</strong>、<strong>recv</strong> 和 <strong>connect</strong>；</li>
<li>针对非阻塞 I&#x2F;O 执行的系统调用则总是立即返回，而不管事件是否已经发生。如果事件没有立即发生，这些系统调用就返回 <code>-1</code>，和出错的情况一样。此时我们必须根据 <code>errno</code> 来区分这两种情况。<ul>
<li>对 <strong>accept</strong>、<strong>send</strong>、<strong>recv</strong> 而言，事件未发生时 <code>errno</code> 通常被设置为 <code>EAGAIN</code>（意为“再来一次”）或者 <code>EWOUDBLOCK</code>（意为“期望阻塞”）；</li>
<li>对 <strong>connect</strong> 而言，<code>errno</code> 则被设置成 <code>EINPROGRESS</code>（意为“在处理中”）。</li>
</ul>
</li>
</ul>
<p><strong>阻塞等待的是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程</strong></p>
<h2 id="同步IO和异步IO"><a href="#同步IO和异步IO" class="headerlink" title="同步IO和异步IO"></a>同步IO和异步IO</h2><ul>
<li>同步IO：请求时，如果数据未准备好，会一直阻塞进程，直到IO操作完成</li>
<li>异步IO:请求时，不管数据是否准备好，都立即返回</li>
</ul>
<h2 id="什么情况下需要I-O多路复用技术"><a href="#什么情况下需要I-O多路复用技术" class="headerlink" title="什么情况下需要I&#x2F;O多路复用技术"></a>什么情况下需要I&#x2F;O多路复用技术</h2><p>传统的 I&#x2F;O 模型中，每个连接或操作都需要一个独立的线程或进程来处理，这会消耗大量的系统资源。而使用 I&#x2F;O 多路复用技术，可以通过一个线程或进程同时监听多个 I&#x2F;O 事件，从而减少了资源的消耗。</p>
<p><strong>IO多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态</strong>，比如调用select和poll函数，传入多个文件描述符，<strong>如果有一个文件描述符就绪，则返回，否则阻塞直到超时</strong>。</p>
<p>这样在处理1000个连接时，<strong>只需要1个线程监控就绪状态，对就绪的每个连接开一个线程处理就可以了，这样需要的线程数大大减少，减少了内存开销和上下文切换的CPU开销。</strong></p>
<h2 id="五种I-O模型"><a href="#五种I-O模型" class="headerlink" title="五种I&#x2F;O模型"></a>五种I&#x2F;O模型</h2><p><strong>阻塞 I&#x2F;O 模型（Blocking I&#x2F;O）：</strong></p>
<ul>
<li>在阻塞 I&#x2F;O 模型中，当应用程序发起一个 I&#x2F;O 操作时，它会被阻塞，直到操作完成。</li>
<li>这意味着应用程序无法执行其他任务，直到 I&#x2F;O 操作完成。</li>
</ul>
<p><strong>非阻塞 I&#x2F;O 模型（Non-blocking I&#x2F;O）：</strong></p>
<ul>
<li>在非阻塞 I&#x2F;O 模型中，应用程序可以继续执行其他任务而不必等待 I&#x2F;O 操作的完成。</li>
<li>当一个 I&#x2F;O 操作发起后，应用程序可以立即返回并执行其他任务，然后周期性地检查 I&#x2F;O 操作是否完成。</li>
</ul>
<p><strong>多路复用 I&#x2F;O 模型（I&#x2F;O Multiplexing）：</strong></p>
<ul>
<li>多路复用 I&#x2F;O 模型使用 <code>select</code>、<code>poll</code> 或 <code>epoll</code> 等机制，允许应用程序监视多个文件描述符，等待其中任何一个变为可读或可写状态。</li>
<li>当有数据准备好时，应用程序会得到通知，然后可以进行读或写操作。</li>
</ul>
<p><strong>信号驱动IO</strong></p>
<ul>
<li>linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。</li>
</ul>
<p><strong>阻塞I&#x2F;O，非阻塞I&#x2F;O，信号驱动I&#x2F;O和I&#x2F;O复用都是同步I&#x2F;O。同步I&#x2F;O指内核向应用程序通知的是就绪事件，比如只通知有客户端连接，要求用户代码自行执行I&#x2F;O操作，异步I&#x2F;O是指内核向应用程序通知的是完成事件，比如读取客户端的数据后才通知应用程序，由内核完成I&#x2F;O操作。</strong></p>
<p><a class="link"   href="https://lantingshuxu.github.io/%E5%85%B6%E4%BB%96/UNIX%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/" >UNIX五种IO模型 | 蓝亭书序 (lantingshuxu.github.io)<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="Reactor模式和Proactor模式"><a href="#Reactor模式和Proactor模式" class="headerlink" title="Reactor模式和Proactor模式"></a>Reactor模式和Proactor模式</h2><ul>
<li><p><code>Reactor</code>模式要求主线程（I&#x2F;O 处理单元）<strong>只负责监听文件描述符上是否有事件发生</strong>。有的话立即通知工作线程（逻辑单元），读写数据、接受新的连接及处理客户请求均在工作线程中完成。通常由同步I&#x2F;O实现。</p>
</li>
<li><p><code>Proactor</code>模式将所有的 I&#x2F;O 操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。通常由异步 I&#x2F;O （<code>aio_read()</code>和<code>aid_write()</code>）实现。</p>
</li>
</ul>
<p>因此，<strong>Reactor 可以理解为「来了事件操作系统通知应用进程，让应用进程来处理」</strong>，而 <strong>Proactor 可以理解为「来了事件操作系统来处理，处理完再通知应用进程」</strong>。</p>
<p><strong>Reactor 模式是基于「待完成」的 I&#x2F;O 事件，而 Proactor 模式则是基于「已完成」的 I&#x2F;O 事件</strong>。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>C++ 网络编程 Reactor</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis入门</title>
    <url>/2024/06/11/Redis%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="Redis入门"><a href="#Redis入门" class="headerlink" title="Redis入门"></a>Redis入门</h1><h2 id="什么是Redis？"><a href="#什么是Redis？" class="headerlink" title="什么是Redis？"></a>什么是Redis？</h2><p><code>Redis</code>是一个开源的<strong>内存键值存储数据库</strong>，它可以用作数据库、缓存和消息中间件。<code>Redis</code>支持多种数据结构，如字符串、哈希、列表、集合和有序集。它还提供了用于数据备份、恢复和复制的功能，使其成为许多应用程序的理想选择。</p>
<h3 id="内存数据库的优缺点"><a href="#内存数据库的优缺点" class="headerlink" title="内存数据库的优缺点"></a>内存数据库的优缺点</h3><h4 id="内存数据库的优点和缺点"><a href="#内存数据库的优点和缺点" class="headerlink" title="内存数据库的优点和缺点"></a>内存数据库的优点和缺点</h4><p><strong>优点：</strong></p>
<ul>
<li><strong>速度：</strong>内存数据库如<code>Redis</code>能够提供快速的读写能力，因为内存的访问速度远超过磁盘。</li>
<li><strong>低延迟：</strong>数据存取的响应时间短，适合需要快速响应的应用。</li>
<li><strong>灵活性：</strong>由于数据结构存储在内存中，<code>Redis</code>等内存数据库支持丰富的数据类型和操作。</li>
<li><strong>简化的数据模型：</strong>键值存储方式简化了数据模型，便于开发和维护。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>成本：</strong>内存通常比磁盘更昂贵，大量的数据存储需要大量的内存，可能导致高成本。</li>
<li><strong>数据持久性风险：</strong>如果没有合适的持久化策略，突然的系统崩溃可能导致数据丢失。</li>
<li><strong>数据容量限制：</strong>由于依赖内存，数据的容量受到物理内存大小的限制。</li>
</ul>
<h2 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取redis最新版本</span></span><br><span class="line">wget http://download.redis.io/releases/redis-6.2.6.tar.gz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压</span></span><br><span class="line">tar -zxvf redis-6.2.6.tar.gz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译</span></span><br><span class="line">cd redis-6.2.6/</span><br><span class="line">make</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装  指定安装的根目录</span></span><br><span class="line">cd src </span><br><span class="line">make install PREFIX=/usr/local/redis</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试</span></span><br><span class="line">redis-server --version</span><br></pre></td></tr></table></figure>

<h2 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h2><h3 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动服务端</span></span><br><span class="line">redis-server</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动客户端(本地)</span></span><br><span class="line">redis-cli</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">远程连接服务端(-p 6379)</span></span><br><span class="line">redis-cli -h host -p port -a passwd</span><br></pre></td></tr></table></figure>

<h3 id="KEY命令"><a href="#KEY命令" class="headerlink" title="KEY命令"></a>KEY命令</h3><table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a class="link"   href="https://redis.com.cn/commands/del.html" >DEL<i class="fas fa-external-link-alt"></i></a></td>
<td align="left">用于删除 key</td>
</tr>
<tr>
<td align="left"><a class="link"   href="https://redis.com.cn/commands/dump.html" >DUMP<i class="fas fa-external-link-alt"></i></a></td>
<td align="left">序列化给定 key ，并返回被序列化的值</td>
</tr>
<tr>
<td align="left"><a class="link"   href="https://redis.com.cn/commands/exists.html" >EXISTS<i class="fas fa-external-link-alt"></i></a></td>
<td align="left">检查给定 key 是否存在</td>
</tr>
<tr>
<td align="left"><a class="link"   href="https://redis.com.cn/commands/expire.html" >EXPIRE<i class="fas fa-external-link-alt"></i></a></td>
<td align="left">为给定 key 设置过期时间</td>
</tr>
<tr>
<td align="left"><a class="link"   href="https://redis.com.cn/commands/expireat.html" >EXPIREAT<i class="fas fa-external-link-alt"></i></a></td>
<td align="left">用于为 key 设置过期时间，接受的时间参数是 UNIX 时间戳</td>
</tr>
<tr>
<td align="left"><a class="link"   href="https://redis.com.cn/commands/pexpire.html" >PEXPIRE<i class="fas fa-external-link-alt"></i></a></td>
<td align="left">设置 key 的过期时间，以毫秒计</td>
</tr>
<tr>
<td align="left"><a class="link"   href="https://redis.com.cn/commands/pexpireat.html" >PEXPIREAT<i class="fas fa-external-link-alt"></i></a></td>
<td align="left">设置 key 过期时间的时间戳(unix timestamp)，以毫秒计</td>
</tr>
<tr>
<td align="left"><a class="link"   href="https://redis.com.cn/commands/keys.html" >KEYS<i class="fas fa-external-link-alt"></i></a></td>
<td align="left">查找所有符合给定模式的 key</td>
</tr>
<tr>
<td align="left"><a class="link"   href="https://redis.com.cn/commands/move.html" >MOVE<i class="fas fa-external-link-alt"></i></a></td>
<td align="left">将当前数据库的 key 移动到给定的数据库中</td>
</tr>
<tr>
<td align="left"><a class="link"   href="https://redis.com.cn/commands/persist.html" >PERSIST<i class="fas fa-external-link-alt"></i></a></td>
<td align="left">移除 key 的过期时间，key 将持久保持</td>
</tr>
<tr>
<td align="left"><a class="link"   href="https://redis.com.cn/commands/pttl.html" >PTTL<i class="fas fa-external-link-alt"></i></a></td>
<td align="left">以毫秒为单位返回 key 的剩余的过期时间</td>
</tr>
<tr>
<td align="left"><a class="link"   href="https://redis.com.cn/commands/ttl.html" >TTL<i class="fas fa-external-link-alt"></i></a></td>
<td align="left">以秒为单位，返回给定 key 的剩余生存时间(</td>
</tr>
<tr>
<td align="left"><a class="link"   href="https://redis.com.cn/commands/randomkey.html" >RANDOMKEY<i class="fas fa-external-link-alt"></i></a></td>
<td align="left">从当前数据库中随机返回一个 key</td>
</tr>
<tr>
<td align="left"><a class="link"   href="https://redis.com.cn/commands/rename.html" >RENAME<i class="fas fa-external-link-alt"></i></a></td>
<td align="left">修改 key 的名称</td>
</tr>
<tr>
<td align="left"><a class="link"   href="https://redis.com.cn/commands/renamenx.html" >RENAMENX<i class="fas fa-external-link-alt"></i></a></td>
<td align="left">仅当 newkey 不存在时，将 key 改名为 newkey</td>
</tr>
<tr>
<td align="left"><a class="link"   href="https://redis.com.cn/commands/type.html" >TYPE<i class="fas fa-external-link-alt"></i></a></td>
<td align="left">返回 key 所储存的值的类型</td>
</tr>
</tbody></table>
<h3 id="String字符串类型"><a href="#String字符串类型" class="headerlink" title="String字符串类型"></a>String字符串类型</h3><blockquote>
<p><code>Redis</code>的<code>Strings</code>存储字节序列，包括文本、序列化对象和二进制数组。因此，字符串是最基本的<code>Redis</code>数据类型。它们通常用于缓存，但它们支持额外的功能，让您也可以实现计数器并执行按位操作。</p>
</blockquote>
<h4 id="获取和设置字符串"><a href="#获取和设置字符串" class="headerlink" title="#获取和设置字符串"></a><a class="link"   href="https://www.redisio.com/Data-types/Strings.html#%E8%8E%B7%E5%8F%96%E5%92%8C%E8%AE%BE%E7%BD%AE%E5%AD%97%E7%AC%A6%E4%B8%B2" >#<i class="fas fa-external-link-alt"></i></a>获取和设置字符串</h4><ul>
<li><code>SET</code> 存储一个字符串值。</li>
<li><code>SETNX</code> 仅当键不存在时才存储字符串值。用于实现锁。</li>
<li><code>GET</code> 检索字符串值。</li>
<li><code>MGET</code> 在单个操作中检索多个字符串值。</li>
</ul>
<h4 id="管理计数器"><a href="#管理计数器" class="headerlink" title="#管理计数器"></a><a class="link"   href="https://www.redisio.com/Data-types/Strings.html#%E7%AE%A1%E7%90%86%E8%AE%A1%E6%95%B0%E5%99%A8" >#<i class="fas fa-external-link-alt"></i></a>管理计数器</h4><ul>
<li><code>INCRBY</code> 以原子方式递增（并在传递负数时递减）存储在给定键处的计数器。</li>
<li>浮点计数器存在另一个命令： <code>INCRBYFLOAT</code>。</li>
</ul>
<h3 id="List列表类型"><a href="#List列表类型" class="headerlink" title="List列表类型"></a>List列表类型</h3><blockquote>
<p>Redis lists是字符串值的链表。Redis 列表经常用于：</p>
<ul>
<li>实现堆栈和队列。</li>
<li>为后台工作系统构建队列管理。</li>
</ul>
</blockquote>
<h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><ul>
<li><code>LPUSH</code> 将一个新元素添加到列表的头部； <code>RPUSH</code> 添加到尾巴。</li>
<li><code>LPOP</code> 从列表的头部移除并返回一个元素； <code>RPOP</code> 做同样的事情，但来自列表的尾部。</li>
<li><code>LLEN</code> 返回列表的长度。</li>
<li><code>LMOVE</code> 原子地将元素从一个列表移动到另一个列表。</li>
<li><code>LTRIM</code> 将列表减少到指定的元素范围。</li>
</ul>
<h4 id="阻塞命令"><a href="#阻塞命令" class="headerlink" title="#阻塞命令"></a><a class="link"   href="https://www.redisio.com/Data-types/Lists.html#%E9%98%BB%E5%A1%9E%E5%91%BD%E4%BB%A4" >#<i class="fas fa-external-link-alt"></i></a>阻塞命令</h4><p>列表支持几个阻塞命令。例如：</p>
<ul>
<li><code>BLPOP</code> 从列表的头部删除并返回一个元素。如果列表为空，则命令会阻塞，直到元素可用或达到指定的超时。</li>
<li><code>BLMOVE</code> 原子地将元素从源列表移动到目标列表。如果源列表为空，则该命令将阻塞，直到有新元素可用。</li>
</ul>
<h3 id="Set集合类型"><a href="#Set集合类型" class="headerlink" title="Set集合类型"></a>Set集合类型</h3><blockquote>
<p>Redis Sets唯一字符串（成员）的无序集合。您可以使用 Redis 集高效地：</p>
<ul>
<li>跟踪唯一项目（例如，跟踪访问给定博客文章的所有唯一 IP 地址）。</li>
<li>表示关系（例如，具有给定角色的所有用户的集合）。</li>
<li>执行常见的集合运算，例如交集、并集和差集。</li>
</ul>
</blockquote>
<h4 id="基本命令-1"><a href="#基本命令-1" class="headerlink" title="基本命令"></a>基本命令</h4><ul>
<li><code>SADD</code> 将新成员添加到集合中。</li>
<li><code>SREM</code> 从集合中删除指定的成员。</li>
<li><code>SISMEMBER</code> 测试一个字符串的集合成员资格。</li>
<li><code>SINTER</code> 返回两个或多个集合共有的成员集合（即交集）。</li>
<li><code>SCARD</code> 返回集合的大小（也称为基数）。</li>
</ul>
<h3 id="Hash哈希类型"><a href="#Hash哈希类型" class="headerlink" title="Hash哈希类型"></a>Hash哈希类型</h3><blockquote>
<p>Redis <code>Hash</code>是结构为字段值对集合的记录类型。您可以使用散列来表示基本对象并存储计数器分组等</p>
</blockquote>
<h4 id="基本命令-2"><a href="#基本命令-2" class="headerlink" title="基本命令"></a>基本命令</h4><ul>
<li><code>HSET</code> 设置散列上一个或多个字段的值。</li>
<li><code>HGET</code> 返回给定字段的值。</li>
<li><code>HMGET</code> 返回一个或多个给定字段的值。</li>
<li><code>HINCRBY</code> 将给定字段的值增加提供的整数。</li>
</ul>
<h3 id="Zset有序集合类型"><a href="#Zset有序集合类型" class="headerlink" title="Zset有序集合类型"></a>Zset有序集合类型</h3><blockquote>
<p>Redis 排序集是由相关分数排序的唯一字符串（成员）的集合。当多个字符串具有相同的分数时，这些字符串按字典顺序排列。排序集的一些用例包括：</p>
<ul>
<li>排行榜。例如，您可以使用排序集轻松维护大型在线游戏中最高分的有序列表。</li>
<li>速率限制器。特别是，您可以使用排序集来构建滑动窗口速率限制器，以防止过多的 API 请求。</li>
</ul>
</blockquote>
<h4 id="基本命令-3"><a href="#基本命令-3" class="headerlink" title="基本命令"></a>基本命令</h4><ul>
<li><code>ZADD</code> 将新成员和相关分数添加到排序集中。如果成员已经存在，则更新分数。</li>
<li><code>ZRANGE</code> 返回在给定范围内排序的有序集合的成员。</li>
<li><code>ZRANK</code> 返回提供的成员的排名，假设排序是按升序排列的。</li>
<li><code>ZREVRANK</code> 返回提供的成员的排名，假设排序集是按降序排列的。</li>
</ul>
<h3 id="Geospatial地理位置详解"><a href="#Geospatial地理位置详解" class="headerlink" title="Geospatial地理位置详解"></a>Geospatial地理位置详解</h3><blockquote>
<p>Redis Geospatial索引可让您存储坐标并搜索它们。此数据结构对于查找给定半径或边界框内的附近点很有用。</p>
</blockquote>
<h4 id="基本命令-4"><a href="#基本命令-4" class="headerlink" title="基本命令"></a>基本命令</h4><ul>
<li><code>GEOADD</code> 将位置添加到给定的地理空间索引（请注意，使用此命令，经度位于纬度之前）。</li>
<li><code>GEOSEARCH</code> 返回具有给定半径或边界框的位置。</li>
</ul>
<h3 id="Hyperloglog基数统计"><a href="#Hyperloglog基数统计" class="headerlink" title="Hyperloglog基数统计"></a>Hyperloglog基数统计</h3><blockquote>
<p><code>HyperLogLog</code> 是一种估计集合基数的数据结构。作为一种概率数据结构，<code>HyperLogLog </code>以完美的准确性换取了高效的空间利用。</p>
<p><code>Redis HyperLogLog </code>实现最多使用 12 KB，并提供 0.81% 的标准误差。</p>
</blockquote>
<h4 id="基本命令-5"><a href="#基本命令-5" class="headerlink" title="基本命令"></a>基本命令</h4><ul>
<li><code>PFADD</code> 将项目添加到 <code>HyperLogLog</code>。</li>
<li><code>PFCOUNT</code> 返回集合中项目数的估计值。</li>
<li><code>PFMERGE</code> 将两个或多个 <code>HyperLogLog </code>合并为一个。</li>
</ul>
<h3 id="Bitmap位图"><a href="#Bitmap位图" class="headerlink" title="Bitmap位图"></a>Bitmap位图</h3><blockquote>
<p><code>Redis Bitmaps</code>是字符串数据类型的扩展，可让您将字符串视为位向量。您还可以对一个或多个字符串执行按位运算。<code>Bitmaps</code>用例的一些示例包括：</p>
<ul>
<li>对于集合的成员对应于整数 0-N 的情况，有效的集合表示。</li>
<li>对象权限，每个位代表一个特定的权限，类似于文件系统存储权限的方式。</li>
</ul>
</blockquote>
<h4 id="基本命令-6"><a href="#基本命令-6" class="headerlink" title="基本命令"></a>基本命令</h4><ul>
<li><code>SETBIT</code> 将提供的偏移量设置为 0 或 1。</li>
<li><code>GETBIT</code> 返回给定偏移量的位值。</li>
<li><code>BITOP</code> 允许您对一个或多个字符串执行按位运算。</li>
</ul>
<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><blockquote>
<p>什么是持久化？</p>
</blockquote>
<p>将内存中的数据保存到硬盘或其他长期存储介质中，从而确保即使在系统崩溃、断电或其他突发事件中，数据也不会丢失。</p>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><blockquote>
<p>什么是RDB?</p>
</blockquote>
<p><code>RDB</code>持久化方式是<code>Redis</code>将当前内存中的数据快照（snapshot）保存到硬盘的过程。换句话说，<code>Redis</code>会创建一个代表某一时刻的数据集的磁盘文件。</p>
<blockquote>
<p>RDB生成的流程图</p>
</blockquote>
<p><img   src="https://segmentfault.com/img/remote/1460000044652260/view"  alt="preview"></p>
<blockquote>
<p>触发机制</p>
</blockquote>
<ol>
<li><code>save</code>的规则满足的情况下，会自动触发<code>rdb</code>规则</li>
<li>执行<code>flushall</code>命令，也会触发<code>rdb</code>规则</li>
<li>退出<code>redis</code>，也会触发<code>rdb</code>规则</li>
</ol>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">redis 配置文件 save 指令设置： </span><br><span class="line">save 3600 1        # 3600秒内如果超过1个key被修改则生成 RDB</span><br><span class="line">save 300 100       # 300秒内如果超过100个key被修改则生成 RDB</span><br><span class="line">save 60 10000      # 60秒内如果超过10000个key被修改则生成 RDB</span><br></pre></td></tr></table></figure>



<blockquote>
<p>如何恢复rdb文件</p>
</blockquote>
<ol>
<li><p>只需要将<code>rdb</code>文件放在<code>redis</code>启动目录即可，<code>redis</code>启动的时候会自动检查<code>dump.rdb</code>恢复其中的数据</p>
</li>
<li><p>查看<code>dump.rdb</code>存在的位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config get dir</span><br></pre></td></tr></table></figure></li>
</ol>
<p>优点：</p>
<ol>
<li><strong>快速备份</strong>：<code>RDB</code>可以迅速为你创建一个数据的“快照”，这是一个备份文件，方便你存储或者迁移数据。</li>
<li><strong>启动快</strong>：当<code>Redis</code>重新启动时，<code>RDB</code>能帮助它更快速地加载数据，因为它直接读取一个完整的数据文件。</li>
<li><strong>节省空间</strong>：与其他持久化方式相比，<code>RDB</code>的文件大小通常较小，因为它是经过压缩的。</li>
<li>适合大规模的数据恢复</li>
<li>对数据完整性要求不高</li>
</ol>
<p>缺点：</p>
<ol>
<li>需要一定的时间间隔进行操作。如果<code>redis</code>意外宕机，最后一次修改的数据就会丢失</li>
<li><code>fork</code>进程的时候，会占用一定的内存空间</li>
</ol>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><blockquote>
<p>什么是AOF</p>
</blockquote>
<p><code>Redis</code>中的 <code>AOF</code> 持久化方式旨在持续地保存服务器上的所有修改操作。每当执行一个会改变数据的命令时，<code>Redis </code>都会将该命令写入 <code>AOF </code>文件中。这样，当<code> Redis</code>需要恢复数据时，只需执行 <code>OF </code>文件中的命令就可以恢复到原来的状态。</p>
<blockquote>
<p>AOF流程图</p>
</blockquote>
<p><img   src="https://segmentfault.com/img/remote/1460000044652262"  alt="img"></p>
<p><code>AOF </code>持久化的实现主要是以上三步：<strong>命令追加、文件写入、文件同步</strong></p>
<ul>
<li><strong>命令追加</strong>: 将 <code>redis </code>写操作命令追加到 <code>aof_buf </code>缓冲区</li>
<li><strong>文件写入</strong>: 周期性地将 <code>aof_buf </code>缓冲区的命令写入 <code>AOF</code> 文件的内核缓冲区。</li>
<li><strong>文件同步</strong>:根据配置同步策略，将 <code>AOF</code> 文件缓冲区的内容同步到磁盘。</li>
</ul>
<blockquote>
<p>什么是<code>AOF</code>重写</p>
</blockquote>
<p><code>AOF </code>重写，可以看作是对<code>AOF</code>文件进行的一次“精简”操作。它的目的是减少<code>AOF</code>文件的大小，并去除那些冗余的、不再必要的命令，使得该文件只包含恢复当前数据集所需的最小命令集。</p>
<blockquote>
<p>为什么需要<code>AOF</code>重写</p>
</blockquote>
<p><strong>节省磁盘空间</strong>：随着操作的积累，原始<code>AOF</code>文件可能会变得非常大。通过重写，可以减少文件的大小。</p>
<p><strong>加速恢复速度</strong>：一个更小、更简洁的<code>AOF</code>文件意味着在<code>Redis</code>重启时，数据的恢复过程会更快。</p>
<blockquote>
<p><code>AOF</code>重写流程图</p>
</blockquote>
<p><img   src="https://segmentfault.com/img/remote/1460000044652263"  alt="img"></p>
<p><strong><code>AOF</code> 重写主要有以下四步：</strong></p>
<ul>
<li><code>redis</code> 主进程 <code>fork</code> 子进程来进行 <code>AOF</code> 的重写，生成 <code>AOF</code> 文件。</li>
<li>在子进程进行 <code>AOF</code> 重写的同时，<code>redis </code>主进程将新的写操作命令写入<code> AOF</code>重写缓冲区</li>
<li>主进程将 <code>AOF </code>重写缓冲区的内容写入到新的<code> AOF</code> 文件中</li>
<li>使用新的 <code>AOF </code>文件替换旧的 <code>AOF </code>文件</li>
</ul>
<blockquote>
<p><code>AOF</code>文件错位了怎么办？</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># redis 提供了一个修复aof文件的工具</span><br><span class="line">redis-check-aof --fix appendonly.aof</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>AOF</code>持久化的优缺点</p>
</blockquote>
<p><strong>优点</strong>：</p>
<p><strong>不轻易丢数据</strong>：<code>AOF</code>记录了所有的写操作，所以即使服务器突然断电，数据丢失的机会也很小。</p>
<p><strong>易于理解</strong>：<code>AOF</code>是一个文本文件，里面就是一系列的命令，你可以打开查看。</p>
<p><strong>出问题也能救</strong>：如果<code>AOF</code>文件最后有点损坏，<code>Redis</code>也能够修复它，避免大量数据丢失。</p>
<p><strong>缺点</strong>：</p>
<p><strong>可能会慢一些</strong>：因为要不断写入操作，所以比<code>RDB</code>要慢一点。</p>
<p><strong>文件可能很大</strong>：<code>AOF</code>会记录所有操作，所以文件可能迅速增大，占用更多空间。</p>
<p><strong>恢复时间长</strong>：如果需要从 <code>AOF</code>文件中恢复数据，由于文件可能很大，所以这个过程可能会比较慢。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改配置文件redis.conf</span></span><br><span class="line">appendonly yes</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置文件存储路径</span></span><br><span class="line">dir</span><br></pre></td></tr></table></figure>

<h2 id="Redis发布订阅"><a href="#Redis发布订阅" class="headerlink" title="Redis发布订阅"></a>Redis发布订阅</h2><p>发布&#x2F;订阅模式是一种消息通信模式，其中消息的发送者称为发布者（Publisher），而消息的接收者称为订阅者（Subscriber）。发布者将消息发布到特定的频道（Channel），而订阅者则可以订阅一个或多个频道，以接收发布者发送的消息。</p>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/image-20240521155708527.png"  alt="image-20240521155708527"></p>
<blockquote>
<p>订阅端</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 订阅一个频道</span><br><span class="line">SUBSCRIBE 频道</span><br><span class="line"># 退订</span><br><span class="line">UNSUBSCRIBE 频道</span><br><span class="line"># 列出当前活跃的频道</span><br><span class="line">PUBSUB CHANNELS</span><br></pre></td></tr></table></figure>



<blockquote>
<p>发布端</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 发布者发布消息</span><br><span class="line">PUBLISH 频道 消息</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用场景</p>
</blockquote>
<ol>
<li>实时消息系统</li>
<li>实时聊天（频道当做聊天室）</li>
<li>订阅，关注系统</li>
</ol>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><blockquote>
<p>什么是主从复制</p>
</blockquote>
<p>主从复制，是指将一台<code>Redis</code>服务器的数据，复制到其他的<code>Redis</code>服务器。前者称为主节点<code>(master/leader)</code>，后者称为从节点<code>(slave/follower)</code>;数据的复制是单向的,只能由主节点到从节点。<code>Master</code>以写为主，<code>Slave</code> 以读为主。<br><strong>默认情况下，每台<code>Redis</code>服务器都是主节点</strong>;且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。</p>
<blockquote>
<p>主从复制的作用</p>
</blockquote>
<p>1、<strong>数据冗余</strong>:主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式,<br>2、<strong>故障恢复</strong>:当主节点出现问题时,可以由从节点提供服务，实现快速的故障恢复;实际上是一种服务的冗余。<br>3、<strong>负载均衡</strong>:在主从复制的基础上,配合读写分离，可以由主节点提供写服务，由从节点提供读服务(即写<code>Redis</code>数据时应用连接主节点，读<code>Redis</code>数据时应用连接从节点)，分担服务器负载;尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高<code>Redis</code>服务器的并发量。<br>4、<strong>高可用基石</strong>:除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是<code>Redis</code>高可用的基础。</p>
<p>一般来说，要将<code>Redis</code>运用于工程项目中，只使用一台<code>Redis</code>是万万不能的，原因如下:<br>1、从结构上，单个<code>Redis</code>服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大;<br>2、从容量上，单个<code>Redis</code>服务器内存容量有限，就算一台<code>Redis</code>服务器内存容量为<code>256G</code>,也不能将所有内存用作<code>Redis</code>存储内存一般来说，单台<code>Redis</code>最大使用内存不应该超过<code>20G</code>。<br>电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”。</p>
<blockquote>
<p>一主二仆(从机只能读)</p>
</blockquote>
<ol>
<li><p>拷贝多份<code>redis.conf</code>配置文件，配置不同的端口</p>
</li>
<li><p>使用不同的配置文件启动服务器</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看服务器信息</span><br><span class="line">info replication</span><br><span class="line"></span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=6381,state=online,offset=140,lag=0</span><br><span class="line">slave1:ip=127.0.0.1,port=6382,state=online,offset=140,lag=1</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:18528cddafdd479f391e69679d5224e878387823</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:140</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:140</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 配置从机(临时)</span><br><span class="line">SLAVEOF 127.0.0.1 6380</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 配置从机  修改配置文件（永久）</span><br><span class="line">replication IP PORT</span><br></pre></td></tr></table></figure>

<blockquote>
<p>复制原理</p>
</blockquote>
<p><code>Slave</code>启动成功连接到<code>master</code>后会发送一个<code>sync</code>同步命令<code>Master</code>接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，<code>master</code>将传送整个数据文件到<code>slave</code>，并完成一次完全同步。<br><strong>全量复制</strong>:而<code>slave</code>服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p>
<p><strong>增量复制</strong> :<code>Master </code>继续将新的所有收集到的修改命令依次传给<code>slave</code>，完成同步<br>但是只要是重新连接<code>master</code>，一次完全同步(全量复制)将被自动执行</p>
<h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><blockquote>
<p>概述</p>
</blockquote>
<p>主从切换技术的方法是:当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。<code>Redis</code>从<code>2.8</code>开始正式提供了<code>Sentinel</code>(哨兵)架构来解决这个问题。<br>谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。</p>
<p>哨兵模式是一种特殊的模式，首先<code>Redis</code>提供了哨兵的命令,哨兵是一个独立的进程,作为进程,它会独立运行。其原理是<strong>哨兵通过发送命令，等待<code>Redis</code>服务器响应，从而监控运行的多个<code>Redis</code>实例</strong>。</p>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/image-20240521185210946.png"  alt="image-20240521185210946"></p>
<blockquote>
<p>哨兵的作用</p>
</blockquote>
<ul>
<li><p>通过发送命令，让<code>Redis</code>服务器返回监控其运行状态，包括主服务器和从服务器。</p>
</li>
<li><p>当哨兵监测到<code>master</code>宕机，会自动将<code>slave</code>切换成<code>master</code>,然后通过<strong>发布订阅模式</strong>通知其他的从服务器，修改配置文件，让它们切换主机。</p>
<p>然而一个哨兵进程对<code>Redis</code>服务器进行监控，可能会出现问题，为此，可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</p>
</li>
</ul>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/image-20240521185533553.png"  alt="image-20240521185533553"></p>
<p>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行<code>failover</code>过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象称为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时,那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行<code>failover</code>[故障转移]操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。</p>
<ol>
<li><p>配置哨兵配置文件<code>sentinel.conf</code></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">sentinel monitor master 127.0.0.1 6382 1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中<code>master</code>为监控对象起的服务器名称，<code>1</code> 为<strong>至少</strong>有多少个哨兵<strong>同意</strong>迁移的数量。<br>设置为<code>1</code>的话,只需要一个哨兵同意就可以切换,设置成<code>2</code>则需要有两个哨兵都同意才进行切换(将从库转换为主库)</p>
</blockquote>
</li>
<li><p>启动哨兵</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-sentinel /home/redis/sentinel.conf</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="延时复制"><a href="#延时复制" class="headerlink" title="延时复制"></a>延时复制</h3><p>由于所有的<strong>写操作都是先在<code>Master</code>上操作</strong>，然后<strong>同步更新到<code>Slave</code>上</strong>，所以从<code>Master</code>同步到<code>Slave</code>机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，<code>Slave</code>机器数量的增加也会使这个问题更加严重。</p>
<h3 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h3><p><img   src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfaf554fade64453b313732dd4ef045d~tplv-k3u1fbpfcp-zoom-1.image"  alt="image.png"></p>
<p>优先级在<code>redis.conf</code>中默认：<code>slave-priority 100</code>，值<strong>越小优先级越高</strong></p>
<h3 id="哨兵模式的优缺点"><a href="#哨兵模式的优缺点" class="headerlink" title="哨兵模式的优缺点"></a>哨兵模式的优缺点</h3><p>优点</p>
<ol>
<li>哨兵集群，基于主从复制模式，所有的主从配置优点，它全有</li>
<li>主从可以切换，故障可以转移，系统的可用性就会更好</li>
<li>哨兵模式就是主从模式的升级，手动到自动，更加健壮!</li>
</ol>
<p>缺点:</p>
<ol>
<li><code>Redis</code>不好在线扩容的,集群容量一旦到达上限，在线扩容就十分麻烦!</li>
<li>实现哨兵模式的配置其实是很麻烦的，里面有很多选择!</li>
</ol>
<h2 id="Redis缓存穿透和雪崩"><a href="#Redis缓存穿透和雪崩" class="headerlink" title="Redis缓存穿透和雪崩"></a>Redis缓存穿透和雪崩</h2><h3 id="缓存穿透（查不到"><a href="#缓存穿透（查不到" class="headerlink" title="缓存穿透（查不到)"></a>缓存穿透（查不到)</h3><p>缓存穿透的概念很简单，用户想要查询一个数据，发现<code>redis</code>内存数据库没有,也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。</p>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/1303876-20210323212002004-761998061.png"  alt="img"></p>
<p>缓存穿透的发生一般有这两种情况：</p>
<ul>
<li>业务误操作，缓存中的数据和数据库中的数据都被误删除了，所以导致缓存和数据库中都没有数据；</li>
<li>黑客恶意攻击，故意大量访问某些读取不存在数据的业务；</li>
</ul>
<h4 id="解决缓存穿透"><a href="#解决缓存穿透" class="headerlink" title="解决缓存穿透"></a>解决缓存穿透</h4><blockquote>
<ol>
<li>布隆滤波器</li>
</ol>
</blockquote>
<p>布隆滤波器是一种数据结构，对所有可能查询的参数以<code>hash</code>形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力。</p>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/image-20240521193744409.png"  alt="image-20240521193744409"></p>
<blockquote>
<ol start="2">
<li>缓存空对象</li>
</ol>
</blockquote>
<p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间,之后再访问这个数据将会从缓存中获取，保护了后端数据源;</p>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/image-20240521193932036.png"  alt="image-20240521193932036"></p>
<p>但是这种方法会存在两个问题:</p>
<ol>
<li>如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键,因为这当中可能会有很多的空值的键;</li>
<li>即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</li>
</ol>
<h3 id="缓存击穿-量太大，缓存过期"><a href="#缓存击穿-量太大，缓存过期" class="headerlink" title="缓存击穿(量太大，缓存过期)"></a>缓存击穿(量太大，缓存过期)</h3><p>缓存击穿，是指一个<code>key</code>非常热点,在不停的扛着大并发,大并发集中对这一个点进行访问，当这个<code>key</code>在失效的瞬间，持续的大并发就穿破缓存,直接请求数据库，就像在一个屏障上凿开了一个洞。</p>
<p>当某个<code>key</code>在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。</p>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/1303876-20210323211106810-708931506.png"  alt="img"></p>
<h4 id="解决缓存击穿"><a href="#解决缓存击穿" class="headerlink" title="解决缓存击穿"></a>解决缓存击穿</h4><blockquote>
<p>1.设置热点数据永不过期</p>
</blockquote>
<blockquote>
<ol start="2">
<li>加互斥锁</li>
</ol>
</blockquote>
<p>分布式锁:使用分布式锁，保证对于每个<code>key</code>同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。</p>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩：是指在某一个时间段，<strong>缓存集中过期失效</strong>或者**<code>Redis </code>故障宕机**!<br>产生雪崩的原因之一，比如在写本文的时候,马上就要到双十二零点,很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/1303876-20210323193532640-1158491496.png"  alt="img"></p>
<p>当大量缓存数据在同一时间过期（失效）或者 <code>Redis</code>故障宕机时，这时大量的用户请求，就直接访问到数据库了，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而造成整个系统崩溃，这就是造成<strong>缓存雪崩</strong>的原因。</p>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/1303876-20210323194138537-1250047237.png"  alt="img"></p>
<h4 id="解决缓存雪崩"><a href="#解决缓存雪崩" class="headerlink" title="解决缓存雪崩"></a>解决缓存雪崩</h4><blockquote>
<ol>
<li><code>redis</code>高可用集群</li>
</ol>
</blockquote>
<p>这个思想的含义是，既然<code>redis</code>有可能挂掉，那我多增设几台<code>redis</code>，这样一台挂掉之后其他的还可以继续工作，其实就是<strong>搭建的集群</strong>。(异地多活!)</p>
<blockquote>
<ol start="2">
<li>限流降级</li>
</ol>
</blockquote>
<p>启动请求限流机制，只将少部分发送到数据库进行处理，再多的请求就在入口直接拒绝服务，等到<code>Redis</code>恢复正常并把缓存预热完后，再解除请求限流的机制。</p>
<blockquote>
<ol start="3">
<li>互斥锁</li>
</ol>
</blockquote>
<p>这个解决方案的思想是，在缓存失效后，通过<strong>加锁或者队列</strong>来控制读数据库写缓存的线程数量。比如对某个<code>key</code>只允许一个线程查询数据和写缓存，其他线程等待。</p>
<blockquote>
<ol start="4">
<li>数据预热</li>
</ol>
</blockquote>
<p>数据加热的含义就是在正式部署之前，先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的<code>key</code>，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/1303876-20210323214406627-90610791.png"  alt="img"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>UML类图</title>
    <url>/2024/06/18/UML%E7%B1%BB%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><blockquote>
<p><strong>类图基础属性</strong></p>
<p>+表示public</p>
<p>-表示private</p>
<p>#表示protected</p>
<p>~表示default</p>
<p>_表示static</p>
<p>斜体表示抽象</p>
<p><strong>类图之间关系</strong></p>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/image-20240607165802362.png"  alt="image-20240607165802362"></p>
<ol>
<li><p>继承：继承表示是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力。</p>
<p>表示方法：继承使用空心三角形+实线表示。</p>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/image-20240607170103069.png"  alt="image-20240607170103069"></p>
</li>
<li><p>实现：实现表示一个class类实现<code>interface</code>接口（可以是多个）的功能。</p>
<p>表示方法：使用空心三角形+虚线表示</p>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/image-20240607170209590.png"  alt="image-20240607170209590"></p>
</li>
<li><p>依赖：对于两个相对独立的对象，当一个对象负责构造另一个对象的实例，或者依赖另一个对象的服务时，这两个对象之间主要体现为依赖关系。<br>表示方法：依赖关系用虚线箭头表示</p>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/image-20240607170316317.png"  alt="image-20240607170316317"></p>
</li>
<li><p>关联：对于两个相对独立的对象，当一个对象的实例与另一个对象的一些特定实例存在固定的对应关系时，这两个对象之间为关联关系。</p>
<p>表示方法：关联关系用实线箭头表示</p>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/image-20240607170403521.png"  alt="image-20240607170403521"></p>
</li>
<li><p>聚合：表示一种弱的‘拥有’关系，即<code>has-a</code>的关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分。 两个对象具有各自的生命周期。</p>
<p>表示方法：聚合关系用空心的菱形+实线箭头表示</p>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/image-20240607170518709.png"  alt="image-20240607170518709"></p>
</li>
<li><p>组合：组合是一种强的‘拥有’关系，是一种<code>contains-a</code>的关系，体现了严格的部分和整体关系，部分和整体的生命周期一样。<br>表示方法：组合关系用实心的菱形+实线箭头表示，还可以使用连线两端的数字表示某一端有几个实例</p>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/image-20240607170613673.png"  alt="image-20240607170613673"></p>
</li>
</ol>
</blockquote>
]]></content>
      <tags>
        <tag>uml</tag>
      </tags>
  </entry>
  <entry>
    <title>moduo之Buffer</title>
    <url>/2024/06/06/moduo%E4%B9%8BBuffer/</url>
    <content><![CDATA[<h1 id="Muduo中的Buffer"><a href="#Muduo中的Buffer" class="headerlink" title="Muduo中的Buffer"></a>Muduo中的Buffer</h1><p><code>Buffer</code>类其实是封装了一个用户缓冲区，以及向这个缓冲区写数据读数据等一系列控制方法。</p>
<h2 id="为什么需要有应用层缓冲区？"><a href="#为什么需要有应用层缓冲区？" class="headerlink" title="为什么需要有应用层缓冲区？"></a><strong>为什么需要有应用层缓冲区？</strong></h2><p>在非阻塞网络编程中，非阻塞IO的核心思想是<strong>避免阻塞在<code>read()/write()</code>或其他IO系统调用上</strong>，可以最大限度复用<code>thread-of-control</code>，让一个线程能服务于多个<code>socket</code>连接。而IO线程只能阻塞在I&#x2F;O多路复用函数上，如<code>select()/poll()/epoll_wait()</code>，这样应用层的缓冲区就是必须的，每个<code>TCP socket</code>都要有足够安全的<code>input buffer</code>和<code>output buffer</code>。</p>
<h2 id="Buffer的设计"><a href="#Buffer的设计" class="headerlink" title="Buffer的设计"></a>Buffer的设计</h2><p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/image-20240605143814050.png"  alt="image-20240605143814050"></p>
<p>它使用<code>vector</code>来作为底层容器，可以进行动态的扩容操作。其次，前置的预留字节空间可用于填充数据序列化后的消息长度。该类的构造函数及其成员变量如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 网络库底层的缓冲区类型定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> kCheapPrepend = <span class="number">8</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> kInitialSize = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Buffer</span><span class="params">(<span class="type">size_t</span> initialSize = kInitialSize)</span></span></span><br><span class="line"><span class="function">        : buffer_(kCheapPrepend + initialSize),</span></span><br><span class="line"><span class="function">          readerIndex_(kCheapPrepend),</span></span><br><span class="line"><span class="function">          writerIndex_(kCheapPrepend) </span></span><br><span class="line"><span class="function">    &#123;</span>&#125;<span class="keyword">private</span>:</span><br><span class="line"> 	std::vector&lt;<span class="type">char</span>&gt; buffer_;</span><br><span class="line">    <span class="type">size_t</span> readerIndex_;</span><br><span class="line">    <span class="type">size_t</span> writerIndex_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Buffer</code>类对于预留空间默认为 8 字节，而其默认大小为 8 + 1024，即 1032 字节。</p>
<p>如下三个函数分别返回预留空间大小、可读空间大小和可写空间大小，而 <code>peek()</code> 则返回读指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">readableBytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> writerIndex_ - readerIndex_; &#125;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">writableBytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> buffer_.<span class="built_in">size</span>() - writerIndex_; &#125;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">prependableBytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> readerIndex_; &#125;</span><br><span class="line"><span class="comment">// 返回缓冲区中可读数据的起始地址</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">peek</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">begin</span>() + readerIndex_; &#125;</span><br></pre></td></tr></table></figure>

<p>如下方法定义了如何从缓冲区中读取数据并更新缓冲区的状态。具体来说，它包括两个函数：<code>retrieve(size_t len)</code> 和 <code>retrieveall()</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">retrieve</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="built_in">readableBytes</span>()) &#123;</span><br><span class="line">        readerIndex_ += len;  <span class="comment">// 应用只读取了可读缓冲区数据的一部分就是len，还剩下</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">retrieveall</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">retrieveall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    readerIndex_ = kCheapPrepend;</span><br><span class="line">    writerIndex_ = kCheapPrepend;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>retrieve</code>这个函数的作用是从缓冲区中读取指定长度 <code>len</code> 的数据，并根据读取的长度更新 <code>readerIndex_</code> 和 <code>writerIndex_</code>。<code>retrieveall</code>这个函数的作用是重置缓冲区的状态，使得缓冲区变为空。将读取指针和写入指针都重置到缓冲区的起始位置 <code>kCheapPrepend</code>。这样，缓冲区变为空，可以重新开始接收和处理新的数据。</p>
<p>具体过程如下图：</p>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/image-20240605144601428.png"  alt="image-20240605144601428"></p>
<p>如下函数：<code>retrieveAllAsString()</code> 函数用于将缓冲区中的所有可读数据转换为一个字符串并返回。<code>retrieveAsString(size_t len)</code> 函数用于将缓冲区中指定长度的数据转换为一个字符串并返回，同时更新缓冲区的读取指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把onMessage函数上报的Buffer数据，转成string类型的数据返回</span></span><br><span class="line"><span class="function">std::string <span class="title">retrieveAllAsString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">retrieveAsString</span>(<span class="built_in">readableBytes</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">retrieveAsString</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">result</span><span class="params">(peek(), len)</span></span>;</span><br><span class="line">    <span class="built_in">retrieve</span>(len);  <span class="comment">// 对缓冲区做复位操作</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果可写缓冲区中的空间不够写，就需要扩容。<code>append(const char* data, size_t len)</code> 函数将给定的 <code>data</code> 数据添加到缓冲区中，并更新 <code>writerIndex_</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// buffer_.size - writerIndex_ 表示缓冲区中可写的空间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ensureWritableBytes</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">writableBytes</span>() &lt; len) &#123;</span><br><span class="line">        <span class="built_in">makeSpace</span>(len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把[data, data+len]内存上的数据，添加到writable缓冲区当中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* data, <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ensureWritableBytes</span>(len);</span><br><span class="line">    std::<span class="built_in">copy</span>(data, data + len, <span class="built_in">beginWrite</span>());</span><br><span class="line">    writerIndex_ += len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自动增长"><a href="#自动增长" class="headerlink" title="自动增长"></a>自动增长</h3><p>这个 <code>makeSpace(size_t len)</code> 函数的目的是在缓冲区中腾出足够的空间，以便存储长度为 <code>len</code> 的数据。如果当前缓冲区的可写空间不足，函数将通过扩展缓冲区或重新整理现有数据来确保有足够的空间。让我们逐步分析这个函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeSpace</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断可写缓冲区的大小加上预写缓冲区的大小是否小于len加kCheapPrepend</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">writableBytes</span>() + <span class="built_in">prependableBytes</span>() &lt; len + kCheapPrepend) &#123;</span><br><span class="line">        <span class="comment">// 如果小于，则调整缓冲区的大小</span></span><br><span class="line">        buffer_.<span class="built_in">resize</span>(writerIndex_ + len);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取可读大小</span></span><br><span class="line">        <span class="type">size_t</span> readable = <span class="built_in">readableBytes</span>();</span><br><span class="line">        <span class="comment">// 将从readerIndex_到writerIndex_之间的数据复制到缓冲区的kCheapPrepend位置</span></span><br><span class="line">        std::<span class="built_in">copy</span>(<span class="built_in">begin</span>() + readerIndex_, <span class="built_in">begin</span>() + writerIndex_, <span class="built_in">begin</span>() + kCheapPrepend);</span><br><span class="line">        <span class="comment">// 修改readerIndex_</span></span><br><span class="line">        readerIndex_ = kCheapPrepend;</span><br><span class="line">        <span class="comment">// 修改writerIndex_</span></span><br><span class="line">        writerIndex_ = readerIndex_ + readable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果可写区域的长度和预留区域的长度之和要小于所需长度和初始化预留区域的长度(8)之和，就需要对缓冲区进行扩容，其过程如下图所示，可见，扩容后可写区域的长度即为所需长度 len。</p>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/image-20240605150032071.png"  alt="image-20240605150032071"></p>
<p>否则，则表示预留空间和可写区域还很充足，为此需要将预留区域中多出来的部分移动到可写区域中去。其过程如下图所示，先将可写区域的内容向前移动，使得预留区域恢复为初始化大小，即 8。然后移动读指针和写指针。</p>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/image-20240605150055404.png"  alt="image-20240605150055404"></p>
<p><code>readFd</code>用于从文件描述符 <code>fd</code> 读取数据，并将其存储在缓冲区中。它使用了 <code>readv</code> 函数来一次性读取数据到多个缓冲区。以下是对这段代码的详细解释：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">Buffer::readFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* savedErrno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> extrabuf[<span class="number">65536</span>];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> vec[<span class="number">2</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> writable = <span class="built_in">writableBytes</span>();</span><br><span class="line">    vec[<span class="number">0</span>].iov_base = <span class="built_in">begin</span>() + writerIndex_;</span><br><span class="line">    vec[<span class="number">0</span>].iov_len = writable;</span><br><span class="line">    vec[<span class="number">1</span>].iov_base = extrabuf;</span><br><span class="line">    vec[<span class="number">1</span>].iov_len = <span class="keyword">sizeof</span> extrabuf;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> iovcnt = (writable &lt; <span class="keyword">sizeof</span> extrabuf) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">ssize_t</span> n = sockets::<span class="built_in">readv</span>(fd, vec, iovcnt);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        *savedErrno = errno;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">implicit_cast</span>&lt;<span class="type">size_t</span>&gt;(n) &lt;= writable) &#123;</span><br><span class="line">        writerIndex_ += n;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        writerIndex_ = buffer_.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">append</span>(extrabuf, n - writable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体 <code>iovec</code> 则用于定义一个向量元素，其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">iovec</span> &#123;</span><br><span class="line">    <span class="type">void</span>   *iov_base; <span class="comment">/* Starting address (内存起始地址）*/</span></span><br><span class="line">    <span class="type">size_t</span> iov_len;   <span class="comment">/* Number of bytes to transfer（这块内存长度） */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>iov_base</code> 所指向的缓冲区用于存放网络接受的数据，或者是网络将要发送的数据。而 <code>iov_len</code> 字段用于存放接受数据的最大长度，或者是实际写入的数据长度。</p>
<p>在 <code>readFd</code> 方法中，定义了两个 <code>iovec</code> 结构体，一部分用于将读到的数据放在可写区域，另一部分用于将读到的数据放在额外缓冲区域。然后，使用如下方法进行分散读，即将数据从文件描述符读到分散的内存块中。其中的第三个参数表示<code> iov</code> 的数组长度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">readv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span></span>;</span><br></pre></td></tr></table></figure>

<p>从 <code>readFd</code> 方法中可以看出，如果可写区域的长度小于 65536，则两个内存块都使用，否则只使用可写区域即可。</p>
<p>最后根据 <code>readv</code> 方法的返回值来确定是否需要额外缓冲区，如果返回的字节数要大于可写区域的长度，说明两个内存块都使用了，且可写区域中已经填充满了，其余的数据全部在额外缓冲区中，此时，只需移动写指针到缓冲区的数据末端，然后将额外缓冲区中的数据追加进来即可。</p>
<h2 id="TcpConnection必须要有output-buffer"><a href="#TcpConnection必须要有output-buffer" class="headerlink" title="TcpConnection必须要有output buffer"></a>TcpConnection必须要有output buffer</h2><p>一个常见场景：程序想通过TCP连接发送100K byte数据，但在write()调用中，OS只接收80K（受TCP通告窗口advertised window的控制），而程序又不能原地阻塞等待，事实上也不知道要等多久。程序应该尽快交出控制器，返回到event loop。此时，剩余20K数据怎么办？</p>
<p>对应用程序，它只管生成数据，不应该关系到底数据是一次发送，还是分几次发送，这些应该由网络库操心，程序只需要调用TcpConnection::send()就行。网络库应该接管剩余的20K数据，把它保存到TcpConnection的output buffer，然后注册POLLOUT事件，一旦socket变得可写就立刻发送数据。当然，第二次不一定能完全写入20K，如果有剩余，网络库应该继续关注POLLOUT事件；如果写完20K，网络库应该停止关注POLLOUT，以免造成busy loop。</p>
<p>如果程序又写入50K，而此时output buffer里还有待发20K数据，那么网络库不应该直接调用write()，而应该把这50K数据append到那20K数据之后，等socket变得可写时再一并写入。</p>
<p>如果output buffer里还有待发送数据，而程序又想关闭连接，但对程序而言，调用TcpConnection::send()后就认为数据迟早会发出去，此时网络库不应该直接关闭连接，而要等数据发送完毕。因为此时数据可能还在内核缓冲区中，并没有通过网卡成功发送给接收方。<br>将数据append到buffer，甚至write进内核，都不代表数据成功发送给对端。</p>
<p>综上，要让程序在write操作上不阻塞，网络库必须给每个tcp connection配置output buffer。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>moduo</tag>
      </tags>
  </entry>
  <entry>
    <title>muduo梳理</title>
    <url>/2024/06/08/muduo%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<h1 id="Muduo梳理"><a href="#Muduo梳理" class="headerlink" title="Muduo梳理"></a><code>Muduo</code>梳理</h1><h2 id="使用Muduo搭建简单的服务器"><a href="#使用Muduo搭建简单的服务器" class="headerlink" title="使用Muduo搭建简单的服务器"></a>使用<code>Muduo</code>搭建简单的服务器</h2><ol>
<li>建立事件循环器<code>EventLoop : loop</code></li>
<li>建立服务器对象<code>TcpServer ：server</code></li>
<li>向<code>TcpServer</code>中注册各类事件的用户自定义的回调函数：<code>onConnection</code>,<code>onMessage</code></li>
<li>设置底层线程数量</li>
<li>启动<code>start</code>函数，<code>server.start()</code></li>
<li>开启主线程（<code>mainloop</code>)事件循环<code>loop.loop()</code></li>
</ol>
<h2 id="构建TCP对象"><a href="#构建TCP对象" class="headerlink" title="构建TCP对象"></a>构建TCP对象</h2><p>在<code>TcpServer</code>的构造函数中建立一个<code>Acceptor</code>的对象，在<code>Acceptor</code>的构造函数中创建了一个非阻塞的<code>listenfd</code>，并封装为<code>Channel</code>对象<code>acceptChannel</code>。在<code>Acceptor</code>构造函数中，给<code>acceptChannel</code>设置了一个<code>ReadCallback</code>回调，事件绑定了<code>handleread</code>。当有新用户连接到来时，<code>Poller</code>监听<code>channel</code>发生事件了，然后上报给<code>EventLoop</code>，通知<code>channel</code>处理相应的事件注册。在底层<code>Channel</code>中的<code>handleEvent</code>就会监控到<code>EPOLLIN</code>事件，并执行相应的<code>readCallback()</code>；而对于<code>acceptChannel</code>对应的<code>readCallback()</code>方法，就是执行<code>Accpetor::handleread()</code>，实际上是执行一个<code>newConnectionCallback_()</code>的回调，而<code>newConnectionCallback_()</code>是通过<code>setnewConnectionCallback</code>设置的，而<code>Acceptor</code>是由<code>TcpServer</code>管理的，实际是设置的<code>setnewConnectionCallback</code>是<code>TcpServer::newConnection</code></p>
<blockquote>
<p><code>acceptChannel</code>注册在事件监听器<code>Poller</code>上，<code>acceptChannel</code>发生可读事件（即新用户连接）就会调用 <code>Acceptor::handleRead </code></p>
<p><code>Acceptor::setReadCallback</code> &#x3D;&gt; <code>Acceptor::handleRead </code>&#x3D;&gt; <code>newConnectionCallback</code></p>
<p>​																											||</p>
<p>​																<code>TcpServer</code>的构造函数中设置了<code>acceptor-&gt;setnewConnectionCallback</code></p>
<p>​																											||</p>
<p>​																       实际上设置的就是<code>TcpServer::newConnection</code></p>
<p>注册在<code>mainloop</code>中的<code>acceptor</code>，当有新用户连接到来，最终相应的是<code>TcpServer::newConnection</code></p>
</blockquote>
<p>而<code>TcpServer::newConnection()</code>实际是创建了一个<code>TcpConnection</code>的对象</p>
<h2 id="start-方法调用"><a href="#start-方法调用" class="headerlink" title="start()方法调用"></a><code>start()</code>方法调用</h2><blockquote>
<p><code>threadPool_-&gt;start(threadInitCallback_);</code> &#x2F;&#x2F; 启动底层的loop线程池</p>
<p>​							||</p>
<p>创建<code>loop</code>子线程并开启<code>loop.loop()</code>（子线程）</p>
<p>执行<code>accept::listen()</code>方法，实际上就是将<code>accpetChannel</code>注册在<code>mainloop</code>的<code>Poller</code>上</p>
</blockquote>
<h2 id="开启mainloop的loop（为搭建服务器的最后一步"><a href="#开启mainloop的loop（为搭建服务器的最后一步" class="headerlink" title="开启mainloop的loop（为搭建服务器的最后一步)"></a>开启<code>mainloop</code>的<code>loop</code>（为搭建服务器的最后一步)</h2><h2 id="新用户连接到来"><a href="#新用户连接到来" class="headerlink" title="新用户连接到来"></a>新用户连接到来</h2><blockquote>
<p><code>TcpServer::newConnection</code></p>
<p>​				||</p>
<p>根据轮询算法，选择一个<code>subLoop</code>，即<code>ioloop</code></p>
<p>创建了一个<code>TcpConnection</code>对象，注册相应的回调（<code>close</code>的回调对应<code>TcpServer::removeConnection</code>）</p>
<p>直接调用<code>TcpConnection::connectEstablished</code></p>
<p><code> ioLoop-&gt;runInLoop</code> &#x3D;&gt; <code>TcpConnection::connectEstablished</code>,因为设置了子线程数量（如果没有设置子线程数量，之间在<code>mainloop</code>中执行），<code>runInLoop</code>实际调用的是<code>queueInLoop()</code>，执行<code>wakeup()</code>，通过<code>ioloop</code>的指针找到<code>wakeupfd</code>，向<code>wakeupfd</code>写一个数据，<code>wakeupChannel</code>就发生读事件，当前<code>loop</code>线程(即<code>ioloop</code>)就会被唤醒，唤醒后执行<code>connectEstablished()</code>。</p>
<p>​				||</p>
<p><code>TcpConnection::connectEstablished</code></p>
<p>向<code>poller</code>注册<code>channel</code>的<code>epollin</code>事件，然后执行<code>connectionCallback</code>，对应的就是用户自定义的<code>onConnection</code>函数执行成功，就会有<code>socket</code>和<code>Channel</code>注册在这个<code>subloop</code>上</p>
</blockquote>
<h2 id="连接成功后，数据通信"><a href="#连接成功后，数据通信" class="headerlink" title="连接成功后，数据通信"></a>连接成功后，数据通信</h2><blockquote>
<p>成功建立连接后<br>        ||<br>有可读事件到来，就会执行<code>Channel</code>中的<code>readCallback()</code>，而<code>readCallback()</code>是通过<code>setReadCallback</code>设置的，在<code>TcpConnection</code>中，<code>setReadCallback</code>绑定是<code>TcpConnection::handleRead</code></p>
<p>​		||</p>
<p>开始读数据，读完数据后，执行用户自定义的回调操作<code>onMessage</code>，然后就得到原始字符串，进行业务处理，业务处理完进行响应（如：回送消息）</p>
</blockquote>
<h2 id="连接关闭"><a href="#连接关闭" class="headerlink" title="连接关闭"></a>连接关闭</h2><blockquote>
<p>通信异常或者对端关闭，底层<code>channel</code>都会触发<code>closeCallback</code>的回调，而<code>closeCallback()</code>是通过<code>setCloseCallback</code>设置的。在<code>TcpConnection</code>中，<code>setCloseCallback</code>绑定是<code>TcpConnection::handleClose</code></p>
<p>​													||</p>
<p><code>channel_-&gt;disableAll()</code>，将<code>chanel</code>所有感兴趣的事件，在<code>poller</code>上全部进行删除，然后执行用户的回调</p>
<p>执行<code>closeCallback_(connPtr)</code>,关闭连接的回调  执行的是<code>TcpServer::removeConnection</code>回调方法</p>
<p>​													||</p>
<p>​	将保存所有的<code>TcpConnection</code>连接的<code>map</code>删除，然后获取这条连接对应的<code>ioloop</code>，然后执行<code>TcpConnection::connectDestroyed</code>，把<code>channel</code>从<code>poller</code>中删除掉</p>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>moduo</tag>
      </tags>
  </entry>
  <entry>
    <title>基于epoll的web服务器</title>
    <url>/2024/04/12/%E5%9F%BA%E4%BA%8Eepoll%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h2 id="基于epoll的web服务器-C语言版本"><a href="#基于epoll的web服务器-C语言版本" class="headerlink" title="基于epoll的web服务器(C语言版本)"></a>基于epoll的web服务器(C语言版本)</h2><h3 id="1-初始化监听套接字"><a href="#1-初始化监听套接字" class="headerlink" title="1. 初始化监听套接字"></a>1. 初始化监听套接字</h3><p>包括创建监听套接字，设置端口复用，绑定，设置监听等步骤</p>
<h4 id="1-1-创建监听套接字（socket函数）"><a href="#1-1-创建监听套接字（socket函数）" class="headerlink" title="1.1 创建监听套接字（socket函数）"></a>1.1 创建监听套接字（socket函数）</h4><p><code>socket()</code>打开一个网络通讯端口，如果成功的话，就像<code>open()</code>一样返回一个文件描述符，应用程序可以像读写文件一样用<code>read/write</code>在网络上收发数据，如果<code>socket()</code>调用出错则返回<code>-1</code>。对于<code>IPv4</code>，<code>domain</code>参数指定为<code>AF_INET</code>。对于<code>TCP</code>协议，<code>type</code>参数指定为<code>SOCK_STREAM</code>，表示面向流的传输协议。如果是<code>UDP</code>协议，则<code>type</code>参数指定为<code>SOCK_DGRAM</code>，表示面向数据报的传输协议。<code>protocol</code>参数的介绍从略，指定为0即可。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt; /* See NOTES */</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int socket(int domain, int type, int protocol);</span><br><span class="line">domain:</span><br><span class="line">	AF_INET 这是大多数用来产生socket的协议，使用TCP或UDP来传输，用IPv4的地址</span><br><span class="line">	AF_INET6 与上面类似，不过是来用IPv6的地址</span><br><span class="line">	AF_UNIX 本地协议，使用在Unix和Linux系统上，一般都是当客户端和服务器在同一台及其上的时候使用</span><br><span class="line">type:</span><br><span class="line">	SOCK_STREAM 这个协议是按照顺序的、可靠的、数据完整的基于字节流的连接。这是一个使用最多的socket类型，这个socket是使用TCP来进行传输。</span><br><span class="line">	SOCK_DGRAM 这个协议是无连接的、固定长度的传输调用。该协议是不可靠的，使用UDP来进行它的连接。</span><br><span class="line">	SOCK_SEQPACKET该协议是双线路的、可靠的连接，发送固定长度的数据包进行传输。必须把这个包完整的接受才能进行读取。</span><br><span class="line">	SOCK_RAW socket类型提供单一的网络访问，这个socket类型使用ICMP公共协议。（ping、traceroute使用该协议）</span><br><span class="line">	SOCK_RDM 这个类型是很少使用的，在大部分的操作系统上没有实现，它是提供给数据链路层使用，不保证数据包的顺序</span><br><span class="line">protocol:</span><br><span class="line">	传0 表示使用默认协议。</span><br><span class="line">返回值：</span><br><span class="line">	成功：返回指向新创建的socket的文件描述符，失败：返回-1，设置errno</span><br></pre></td></tr></table></figure>



<h4 id="1-2-设置端口复用（setsockopt函数）"><a href="#1-2-设置端口复用（setsockopt函数）" class="headerlink" title="1.2 设置端口复用（setsockopt函数）"></a>1.2 设置端口复用（setsockopt函数）</h4><p>在<code>server</code>的TCP连接没有完全断开之前不允许重新监听是不合理的。因为，TCP连接没有完全断开指的是<code>connfd</code>（127.0.0.1:6666）没有完全断开，而我们重新监听的是<code>listenfd</code>（0.0.0.0:6666），虽然是占用同一个端口，但<code>IP</code>地址不同，<code>connfd</code>对应的是与某个客户端通讯的一个具体的<code>IP</code>地址，而<code>listenfd</code>对应的是<code>wildcard address</code>。解决这个问题的方法是使用<code>setsockopt()</code>设置<code>socket</code>描述符的选项<code>SO_REUSEADDR</code>为1，表示允许创建端口号相同但<code>IP</code>地址不同的多个<code>socket</code>描述符。</p>
<p>在server代码的socket()和bind()调用之间插入如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br></pre></td></tr></table></figure>

<h4 id="1-3-绑定（bind函数）"><a href="#1-3-绑定（bind函数）" class="headerlink" title="1.3 绑定（bind函数）"></a>1.3 绑定（bind函数）</h4><p>服务器程序所监听的网络地址和端口号通常是固定不变的，客户端程序得知服务器程序的地址和端口号后就可以向服务器发起连接，因此服务器需要调用<code>bind</code>绑定一个固定的网络地址和端口号。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt; /* See NOTES */</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br><span class="line">sockfd：</span><br><span class="line">	socket文件描述符</span><br><span class="line">addr:</span><br><span class="line">	构造出IP地址加端口号</span><br><span class="line">addrlen:</span><br><span class="line">	sizeof(addr)长度</span><br><span class="line">返回值：</span><br><span class="line">	成功返回0，失败返回-1, 设置errno</span><br></pre></td></tr></table></figure>

<p><code>bind()</code>的作用是将参数<code>sockfd</code>和<code>addr</code>绑定在一起，使<code>sockfd</code>这个用于网络通讯的文件描述符监听<code>addr</code>所描述的地址和端口号。前面讲过，<code>struct sockaddr *</code>是一个通用指针类型，<code>addr</code>参数实际上可以接受多种协议的<code>sockaddr</code>结构体，而它们的长度各不相同，所以需要第三个参数<code>addrlen</code>指定结构体的长度。如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY);	<span class="comment">//INADDR_ANY = 0</span></span><br><span class="line">servaddr.sin_port = htons(<span class="number">8888</span>);</span><br></pre></td></tr></table></figure>

<p>首先将整个结构体清零，然后设置地址类型为<code>AF_INET</code>，<strong>网络地址为</strong><code>INADDR_ANY</code>**，这个宏表示本地的任意<code>IP</code><strong>地址</strong>，因为服务器可能有多个网卡，每个网卡也可能绑定多个<code>IP</code>地址，这样设置可以在所有的<code>IP</code>地址上监听，直到与某个客户端建立了连接时才确定下来到底用哪个<code>IP</code>地址，端口号为8888。</p>
<h4 id="1-4-设置监听-（listen函数）"><a href="#1-4-设置监听-（listen函数）" class="headerlink" title="1.4 设置监听 （listen函数）"></a>1.4 设置监听 （listen函数）</h4><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt; /* See NOTES */</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int listen(int sockfd, int backlog);</span><br><span class="line">sockfd:</span><br><span class="line">	socket文件描述符</span><br><span class="line">backlog:</span><br><span class="line">	排队建立3次握手队列和刚刚建立3次握手队列的链接数和(现在只表示建立链接队列的数量)</span><br></pre></td></tr></table></figure>

<p>查看系统默认<code>backlog</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_max_syn_backlog</span><br></pre></td></tr></table></figure>

<p>典型的服务器程序可以同时服务于多个客户端，当有客户端发起连接时，服务器调用的<code>accept()</code>返回并接受这个连接，如果有大量的客户端发起连接而服务器来不及处理，尚未<code>accept</code>的客户端就处于连接等待状态，<code>listen()</code>声明<code>sockfd</code>处于监听状态，并且最多允许有<code>backlog</code>个客户端处于连接待状态，如果接收到更多的连接请求就忽略。<code>listen()</code>成功返回0，失败返回-1。</p>
<h4 id="1-5-初始化监听套接字（initListenFd函数）"><a href="#1-5-初始化监听套接字（initListenFd函数）" class="headerlink" title="1.5 初始化监听套接字（initListenFd函数）"></a>1.5 初始化监听套接字（initListenFd函数）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化监听套接字</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">initListenFd</span><span class="params">(port)</span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建监听套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 设置端口复用</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ret = setsockopt(lfd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,<span class="keyword">sizeof</span>(opt));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(port);</span><br><span class="line">    addr.sin_addr.s_addr = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret = bind(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;addr,<span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.设置监听</span></span><br><span class="line">    ret = listen(lfd,<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 返回fd</span></span><br><span class="line">    <span class="keyword">return</span> lfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-启动epoll"><a href="#2-启动epoll" class="headerlink" title="2. 启动epoll"></a>2. 启动epoll</h3><p><code>epoll</code>是<code>Linux</code>下<strong>IO多路复用</strong>接口<code>select/poll</code>的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率，因为它会复用文件描述符集合来传递结果而不用迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合，另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入<code>Ready</code>队列的描述符集合就行了。</p>
<p><code>epoll</code>除了提供<code>select/poll</code>那种IO事件的水平触发（Level Triggered）外，还提供了边沿触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少<code>epoll_wait/epoll_pwait</code>的调用，提高应用程序效率。</p>
<h4 id="2-1-创建epoll树-epoll-create"><a href="#2-1-创建epoll树-epoll-create" class="headerlink" title="2.1 创建epoll树  (epoll_create)"></a>2.1 创建epoll树  (epoll_create)</h4><p> 创建一个<code>epoll</code>句柄，参数<code>size</code>用来告诉内核监听的文件描述符的个数，跟内存大小有关。(<strong>参数size已经弃用，只需提供大于0的数字就行</strong>)</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">int epoll_create(int size)		</span><br><span class="line">size：监听数目（内核参考值）</span><br><span class="line">返回值：成功：非负文件描述符；失败：-1，设置相应的errno</span><br></pre></td></tr></table></figure>

<p>可以使用cat命令查看一个进程可以打开的socket描述符上限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/sys/fs/file-max</span><br><span class="line">806425</span><br></pre></td></tr></table></figure>

<p>如有需要，可以通过修改配置文件的方式修改该上限值。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/security/limits.conf</span><br><span class="line">在文件尾部写入以下配置,soft软限制，hard硬限制。如下图所示。</span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 100000</span><br></pre></td></tr></table></figure>

<p><img   src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20231026200903197.png"  alt="image-20231026200903197"></p>
<h4 id="2-2-上树（epoll-ctl函数）"><a href="#2-2-上树（epoll-ctl函数）" class="headerlink" title="2.2 上树（epoll_ctl函数）"></a>2.2 上树（epoll_ctl函数）</h4><p>控制某个<code>epoll</code>监控的文件描述符上的事件：注册、修改、删除。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</span><br><span class="line">    epfd：	为epoll_creat的句柄</span><br><span class="line">    op：		表示动作，用3个宏来表示：</span><br><span class="line">    EPOLL_CTL_ADD (注册新的fd到epfd)，</span><br><span class="line">    EPOLL_CTL_MOD (修改已经注册的fd的监听事件)，</span><br><span class="line">    EPOLL_CTL_DEL (从epfd删除一个fd)；</span><br><span class="line">    event：	告诉内核需要监听的事件</span><br><span class="line"></span><br><span class="line">struct epoll_event &#123;</span><br><span class="line">    __uint32_t events; /* Epoll events */</span><br><span class="line">    epoll_data_t data; /* User data variable */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef union epoll_data &#123;</span><br><span class="line">    void *ptr;</span><br><span class="line">    int fd;</span><br><span class="line">    uint32_t u32;</span><br><span class="line">    uint64_t u64;</span><br><span class="line">&#125; epoll_data_t;</span><br><span class="line"></span><br><span class="line">EPOLLIN ：	表示对应的文件描述符可以读（包括对端SOCKET正常关闭）</span><br><span class="line">EPOLLOUT：	表示对应的文件描述符可以写</span><br><span class="line">EPOLLPRI：	表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）</span><br><span class="line">EPOLLERR：	表示对应的文件描述符发生错误</span><br><span class="line">EPOLLHUP：	表示对应的文件描述符被挂断；</span><br><span class="line">EPOLLET： 	将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)而言的</span><br><span class="line">EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</span><br><span class="line">返回值：成功：0；失败：-1，设置相应的errno</span><br></pre></td></tr></table></figure>

<h4 id="2-3-检测（epoll-wait函数）"><a href="#2-3-检测（epoll-wait函数）" class="headerlink" title="2.3 检测（epoll_wait函数）"></a>2.3 检测（epoll_wait函数）</h4><p>等待所监控文件描述符上有事件的产生，类似于<code>select()</code>调用。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">	int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)</span><br><span class="line">    events：		用来存内核得到事件的集合，可简单看作数组。</span><br><span class="line">    maxevents：	告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，</span><br><span class="line">    timeout：	是超时时间</span><br><span class="line">    -1：	阻塞</span><br><span class="line">    0：	立即返回，非阻塞</span><br><span class="line">    &gt;0：	指定毫秒</span><br><span class="line">    返回值：	成功返回有多少文件描述符就绪，时间到时返回0，出错返回-1</span><br></pre></td></tr></table></figure>

<h4 id="2-4-启动epoll-epollrun函数"><a href="#2-4-启动epoll-epollrun函数" class="headerlink" title="2.4 启动epoll(epollrun函数)"></a>2.4 启动epoll(epollrun函数)</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//启动epoll</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">epollrun</span><span class="params">(<span class="type">int</span> lfd)</span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建epoll树</span></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(epfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. lfd上树</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.data.fd = lfd;</span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    <span class="type">int</span> ret = epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&amp;ev);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_ctl error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 检测(委托内核检测添加到树上的节点)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">evs</span>[1024];</span></span><br><span class="line">    <span class="type">int</span> size = siezof(evs) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> epoll_event);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> num = epoll_wait(epfd,evs,size,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait error&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历发生变化的节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!(evs[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line">                <span class="comment">// 不是读事件</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> fd = evs[i].data.fd;</span><br><span class="line">            <span class="keyword">if</span>(fd == lfd)&#123;</span><br><span class="line">                <span class="comment">// 建立新连接 accept</span></span><br><span class="line">                acceptClient(lfd,epfd);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 主要是接受对端的数据(读数据)</span></span><br><span class="line">                recvHttpRequest(fd,epfd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-建立连接"><a href="#3-建立连接" class="headerlink" title="3. 建立连接"></a>3. 建立连接</h3><h4 id="3-1-建立连接-（accept函数）"><a href="#3-1-建立连接-（accept函数）" class="headerlink" title="3.1 建立连接 （accept函数）"></a>3.1 建立连接 （accept函数）</h4><p><strong>三方握手完成后，服务器调用<code>accept()</code>接受连接</strong>，如果服务器调用<code>accept()</code>时还没有客户端的连接请求，就阻塞等待直到有客户端连接上来。<code>addr</code>是一个传出参数，<code>accept()</code>返回时传出客户端的地址和端口号。<code>addrlen</code>参数是一个传入传出参数（value-result argument），传入的是调用者提供的缓冲区<code>addr</code>的长度以避免缓冲区溢出问题，传出的是客户端地址结构体的实际长度（有可能没有占满调用者提供的缓冲区）。如果给<code>addr</code>参数传<code>NULL</code>，表示不关心客户端的地址。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt; 		/* See NOTES */</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span><br><span class="line">sockdf:</span><br><span class="line">	socket文件描述符</span><br><span class="line">addr:</span><br><span class="line">	传出参数，返回链接客户端地址信息，含IP地址和端口号</span><br><span class="line">addrlen:</span><br><span class="line">	传入传出参数（值-结果）,传入sizeof(addr)大小，函数返回时返回真正接收到地址结构体的大小</span><br><span class="line">返回值：</span><br><span class="line">	成功返回一个新的socket文件描述符，用于和客户端通信，失败返回-1，设置errno</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们的服务器程序结构是这样的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">	cliaddr_len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">	connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;cliaddr_len);</span><br><span class="line">	n = read(connfd, buf, MAXLINE);</span><br><span class="line">	......</span><br><span class="line">	close(connfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个是一个while死循环，每次循环处理一个客户端连接。由于<code>cliaddr_len</code>是传入传出参数，每次调用<code>accept()</code>之前应该重新赋初值。<code>accept()</code>的参数<code>listenfd</code>是先前的监听文件描述符，而<code>accept()</code>的返回值是另外一个文件描述符<code>connfd</code>，之后与客户端之间就通过这个<code>connfd</code>通讯，最后关闭<code>connfd</code>断开连接，而不关闭<code>listenfd</code>，再次回到循环开头<code>listenfd</code>仍然用作<code>accept</code>的参数。<code>accept()</code>成功返回一个文件描述符，出错返回-1。</p>
<h4 id="3-2-epoll事件模型"><a href="#3-2-epoll事件模型" class="headerlink" title="3.2 epoll事件模型"></a>3.2 epoll事件模型</h4><p><code>EPOLL</code>事件有两种模型：</p>
<ul>
<li><p><code>Edge Triggered (ET) </code>边缘触发只有数据到来才触发，不管缓存区中是否还有数据。</p>
</li>
<li><p><code>Level Triggered (LT) </code>水平触发只要有数据都会触发。</p>
</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">思考如下步骤：</span><br><span class="line">1.	假定我们已经把一个用来从管道中读取数据的文件描述符(rfd)添加到epoll描述符。</span><br><span class="line">2.	管道的另一端写入了2KB的数据</span><br><span class="line">3.	调用epoll_wait，并且它会返回rfd，说明它已经准备好读取操作</span><br><span class="line">4.	读取1KB的数据</span><br><span class="line">5.	调用epoll_wait……</span><br></pre></td></tr></table></figure>

<p><strong>ET模式 即Edge Triggered工作模式（边沿触发）</strong></p>
<p>如果我们在第1步将<code>rfd</code>添加到<code>epoll</code>描述符的时候使用了<code>EPOLLET</code>标志，那么在第5步调用<code>epoll_wait</code>之后将有可能会挂起，因为剩余的数据还存在于文件的输入缓冲区内，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候 <code>ET</code> 工作模式才会汇报事件。因此在第5步的时候，调用者可能会放弃等待仍在存在于文件输入缓冲区内的剩余数据。<code>epoll</code>工作在<code>ET</code>模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。最好以下面的方式调用<code>ET</code>模式的<code>epoll</code>接口，在后面会介绍避免可能的缺陷。</p>
<ul>
<li><p>基于非阻塞文件句柄</p>
</li>
<li><p>只有当<code>read</code>或者<code>write</code>返回<code>EAGAIN</code>(非阻塞读，暂时无数据)时才需要挂起、等待。但这并不是说每次<code>read</code>时都需要循环读，直到读到产生一个<code>EAGAIN</code>才认为此次事件处理完成，当<code>read</code>返回的读到的数据长度小于请求的数据长度时，就可以确定此时缓冲中已没有数据了，也就可以认为此事读事件已处理完成。</p>
</li>
</ul>
<p><strong>LT模式即Level Triggered工作模式(水平触发)</strong></p>
<p>与<code>ET</code>模式不同的是，以<code>LT</code>方式调用<code>epoll</code>接口的时候，它就相当于一个速度比较快的<code>poll</code>，无论后面的数据是否被使用。</p>
<p><strong>比较</strong></p>
<p><code>LT(level triggered)</code>：<code>LT</code>是<strong>缺省</strong>的工作方式，并且同时支持<code>block</code>和<code>no-block socket</code>。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的<code>fd</code>进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。**传统的<code>select/poll</code>**都是这种模型的代表。</p>
<p><code>ET(edge-triggered)</code>：**<code>ET</code>是高速工作方式，只支持<code>no-block socket</code>**。在这种模式下，当描述符从未就绪变为就绪时，内核通过<code>epoll</code>告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知。请注意，如果一直不对这个<code>fd</code>作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知<code>**(only once)**</code>.</p>
<h4 id="3-3-阻塞与非阻塞"><a href="#3-3-阻塞与非阻塞" class="headerlink" title="3.3 阻塞与非阻塞"></a>3.3 阻塞与非阻塞</h4><ul>
<li>非阻塞模式可以理解为，执行此套接字的网络调用时，不管是否执行成功，都会立即返回。</li>
</ul>
<p>​		如调用<code>recv( )</code>函数读取网络缓冲区中的数据时，不管是否读到数据都立即返回，而不会一直挂在此函数的调用上。</p>
<ul>
<li>阻塞模式为只有接收到数据后才会返回，套接字默认的会创建堵塞模式。</li>
</ul>
<h4 id="3-4-建立连接（accpetClient函数）"><a href="#3-4-建立连接（accpetClient函数）" class="headerlink" title="3.4 建立连接（accpetClient函数）"></a>3.4 建立连接（accpetClient函数）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">accpetClient</span><span class="params">(<span class="type">int</span> lfd,<span class="type">int</span> epfd)</span>&#123;</span><br><span class="line">    <span class="comment">// 1. 建立连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    cliaddr.sin_family = AF_INET;</span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd,(<span class="keyword">struct</span> sockaddr*)&amp;cliaddr,&amp;len);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> ip[<span class="number">16</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;new client ip=%s port=%d\n&quot;</span>,</span><br><span class="line">    inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr,ip,<span class="number">16</span>),ntohs(cliaddr.sin_port));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 设置非阻塞</span></span><br><span class="line">    <span class="type">int</span> flag = fcntl(cfd,F_GETFL);</span><br><span class="line">    flag |= O_NONBLOCK;</span><br><span class="line">    fcntl(cfd,F_SETFL,flag);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. cfd添加到epoll</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.data.fd = cfd;</span><br><span class="line">    ev.events = EPOLLIN | EPOLLET;      <span class="comment">//边沿模式</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&amp;ev);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_ctl error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-接收客户端发来的http请求"><a href="#4-接收客户端发来的http请求" class="headerlink" title="4. 接收客户端发来的http请求"></a>4. 接收客户端发来的http请求</h3><h4 id="4-1-接收数据-（recv函数）"><a href="#4-1-接收数据-（recv函数）" class="headerlink" title="4.1 接收数据 （recv函数）"></a>4.1 接收数据 （recv函数）</h4><p>接收来自<code>socket</code>缓冲区的数据，当缓冲区没有数据可取时，<code>recv</code>会一直处于阻塞状态()，直到缓冲区至少又一个字节数据可读取，或者对端关闭，并读取所有数据后返回。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">int recv(int sockfd, char * buf, int len, int flags);</span><br><span class="line">sockfd：连接的fd</span><br><span class="line">buf：用于接收数据的缓冲区</span><br><span class="line">len：缓冲区长度</span><br><span class="line">flags：指定调用方式</span><br><span class="line">返回值：成功返回实际读到的字节数。如果recv在copy时出错，那么它返回err，err小于0；如果recv函数在等待协议接收数据时网络中断了，那么它返回0。</span><br></pre></td></tr></table></figure>

<p><strong>read</strong></p>
<p><code>read</code>函数从文件描述符（包括<code>TCP Socket</code>）中读取数据，并将读取的数据存储到指定的缓冲区中。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">ssize_t read(int fd, void *buf, size_t count);</span><br><span class="line">fd：要读取数据的文件描述符，可以是TCP Socket。</span><br><span class="line">buf：存储读取数据的缓冲区。</span><br><span class="line">count：要读取的字节数。</span><br><span class="line">返回值：成功时返回实际读取的字节数，失败时返回-1，并设置errno变量来指示错误的原因。</span><br></pre></td></tr></table></figure>

<p><code>read</code>函数和<code>recv</code>函数都是阻塞调用，即在没有数据可读时会一直阻塞等待。它们的主要区别在于<code>recv</code>函数可以通过<code>flags</code>参数控制一些特殊的行为，如设置<code>MSG_PEEK</code>标志来预览数据而不将其从缓冲区中移除。</p>
<h4 id="4-2-EAGAIN错误"><a href="#4-2-EAGAIN错误" class="headerlink" title="4.2 EAGAIN错误"></a>4.2 EAGAIN错误</h4><p>以<code>O_NONBLOCK</code>的标志打开文件<code>/socket/FIFO</code>，如果你连续做<code>read</code>或者<code>recv</code>操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返回，<code>read</code>函数会返回一个错误<code>EAGAIN</code>，提示你的应用程序现在没有数据可读请稍后再试。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">（epoll的ET模式下设置recv，对应的fd文件描述符设置为非阻塞）下调用了阻塞操作，在该操作没有完成就返回这个错误，这个错误不会破坏socket的同步，不用管它，下次循环接着recv就可以。对非阻塞socket而言，EAGAIN不是一种错误。在VxWorks和Windows上，EAGAIN的名字叫做EWOULDBLOCK。</span><br></pre></td></tr></table></figure>

<h4 id="4-3-接受http请求（recvHttpRequest函数）"><a href="#4-3-接受http请求（recvHttpRequest函数）" class="headerlink" title="4.3 接受http请求（recvHttpRequest函数）"></a>4.3 接受http请求（recvHttpRequest函数）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">recvHttpRequest</span><span class="params">(<span class="type">int</span> cfd,<span class="type">int</span> epfd)</span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4096</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">char</span> tmp[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 1. 接收数据</span></span><br><span class="line">    <span class="keyword">while</span>((len = recv(cfd,tmp,<span class="keyword">sizeof</span>(tmp),<span class="number">0</span>)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(total + len &lt; <span class="keyword">sizeof</span>(buf))&#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(buf + total,tmp,len);</span><br><span class="line">        &#125;</span><br><span class="line">        total += len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 判断数据是否接受完毕</span></span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">-1</span> &amp;&amp; errno == EAGAIN)&#123;</span><br><span class="line">        <span class="comment">// 解析请求行   </span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19</span></span><br><span class="line"><span class="comment">        G E T   / 1 . t x t H  T  T  P  /  1  .  1  /r /n</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">char</span>* pt = <span class="built_in">strstr</span>(buf,<span class="string">&quot;\r\n&quot;</span>);  <span class="comment">//大字符串找小字符串</span></span><br><span class="line">        <span class="type">int</span> reqLen = pt - buf;</span><br><span class="line">        buf[reqLen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 客户端断开连接</span></span><br><span class="line">        epoll_ctl(epfd,EPOLL_CTL_DEL,cfd,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        perror(<span class="string">&quot;recv error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-解析请求行"><a href="#5-解析请求行" class="headerlink" title="5. 解析请求行"></a>5. 解析请求行</h3><h4 id="5-1-格式化拆分字符串-（sscanf函数）"><a href="#5-1-格式化拆分字符串-（sscanf函数）" class="headerlink" title="5.1 格式化拆分字符串 （sscanf函数）"></a>5.1 格式化拆分字符串 （sscanf函数）</h4><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">sprintf（）是把格式化数据输出成（存储到）字符串。</span><br><span class="line">sscanf（）是从字符串中读取格式化的数据。</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">// 函数原型</span><br><span class="line">// 将参数str的字符串根据参数format字符串来转换并格式化数据，转换后的结果存于对应的参数内。</span><br><span class="line">sscanf(const char *str, const char *format, ...)。</span><br><span class="line"></span><br><span class="line">具体功能如下：</span><br><span class="line">（1）根据格式从字符串中提取数据。如从字符串中取出整数、浮点数和字符串等。</span><br><span class="line">（2）取指定长度的字符串</span><br><span class="line">（3）取到指定字符为止的字符串</span><br><span class="line">（4）取仅包含指定字符集的字符串</span><br><span class="line">（5）取到指定字符集为止的字符串</span><br><span class="line"></span><br><span class="line">// 可以使用正则表达式进行字符串的拆分</span><br><span class="line">// shell脚本的时候, 会将正则表达式, 其实就是字符串的匹配规则, 用特殊字符来描述一类字符串</span><br><span class="line">/*</span><br><span class="line">正则匹配规则:</span><br><span class="line">	[1-9]: 匹配一个字符, 这个字符在 1-9 范围内就满足条件</span><br><span class="line">	[2-7]: 匹配一个字符, 这个字符在 2-7 范围内就满足条件</span><br><span class="line">	[a-z]: 匹配一个字符, 这个字符在 a-z 范围内就满足条件</span><br><span class="line">	[A,b,c,D, e, f]: 匹配一个字符, 这个字符是集合中任意一个就满足条件</span><br><span class="line">	[1-9, f-x]: 匹配一个字符, 这个字符是1-9, 或者f-x 集合中的任意一个就满足条件</span><br><span class="line">	[^1]: ^代表否定, 匹配一个字符,这个字符只要不是1就满足条件</span><br><span class="line">	[^2-8]: 匹配一个字符,这个字符只要不在 2-8 范围内就满足条件</span><br><span class="line">	[^a-f]: 匹配一个字符,这个字符只要不在 a-f 范围内就满足条件</span><br><span class="line">	[^ ]: 匹配一个字符,这个字符只要不是空格就满足条件</span><br><span class="line">使用正则表达式如何取匹配字符串:</span><br><span class="line">举例: </span><br><span class="line">	字符串 ==&gt; abcdefg12345AABBCCDD890</span><br><span class="line">	正则表达式: [1-9][a-z], 可以匹配两个字符</span><br><span class="line">	匹配方式: 从原始字符串开始位置遍历, 每遍历一个字符都需要和正则表达式进行匹配, </span><br><span class="line">		满足条件继续向后匹配, 不满足条件, 匹配结束</span><br><span class="line">		从新开始: 从正则表达式的第一个字符重新开始向后一次匹配</span><br><span class="line">			当整个大字符串被匹配一遍, 就结束了</span><br><span class="line">	abcdefg12345AABBCCDD893b</span><br><span class="line">		- 匹配到一个子字符串: 3b</span><br><span class="line">	1a2b3c4d5e6f7g12345AABBCCDD893b</span><br><span class="line">	 - 1a</span><br><span class="line">	 - 2b</span><br><span class="line">	 - 3c</span><br><span class="line">	 - 4d</span><br><span class="line">	 - 5e</span><br><span class="line">	 - 6f</span><br><span class="line">	 - 7g</span><br><span class="line">	 - 3b</span><br><span class="line">*/</span><br><span class="line">sscanf可以支持格式字符%[]：</span><br><span class="line"></span><br><span class="line">(1)-: 表示范围，如：%[1-9]表示只读取1-9这几个数字 %[a-z]表示只读取a-z小写字母，类似地 %[A-Z]只读取大写字母</span><br><span class="line">(2)^: 表示不取，如：%[^1]表示读取除&#x27;1&#x27;以外的所有字符 %[^/]表示除/以外的所有字符</span><br><span class="line">(3),: 范围可以用&quot;,&quot;相连接 如%[1-9,a-z]表示同时取1-9数字和a-z小写字母 </span><br><span class="line">(4)原则：从第一个在指定范围内的数字开始读取，到第一个不在范围内的数字结束%s 可以看成%[] 的一个特例 %[^ ](注意^后面有一个空格！)</span><br></pre></td></tr></table></figure>

<h4 id="5-2-转码"><a href="#5-2-转码" class="headerlink" title="5.2 转码"></a>5.2 转码</h4><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">假设浏览器访问的文件名中有中文: Linux内核.jpg</span><br><span class="line">	- 浏览器在给服务器发送请求的时候, 会自动将中文进制转换: Linux%E5%86%85%E6%A0%B8.jpg</span><br><span class="line">	- 为什么要转换?</span><br><span class="line">		- 在http请求的请求行中不支持中文字符, 如果有中文, 浏览器就会自动将中文进行转换</span><br><span class="line">		- 在服务器端收到的文件名就不是原来的名字了, 因此服务器端就不能识别了</span><br><span class="line">		- 如果服务器端想要正确的处理, 需要将特殊字符串解析成原来的汉字</span><br><span class="line">		</span><br><span class="line">$ unicode 内</span><br><span class="line">UTF-8: e5 86 85 </span><br><span class="line">$ unicode 核</span><br><span class="line">UTF-8: e6 a0 b8</span><br></pre></td></tr></table></figure>

<h4 id="5-3-获取文件信息（stat）"><a href="#5-3-获取文件信息（stat）" class="headerlink" title="5.3 获取文件信息（stat）"></a>5.3 获取文件信息（stat）</h4><p><code>Linux</code> 下可以使用<code>stat </code>命令查看文件的属性，其实这个命令内部就是通过调用<code> stat()</code>函数来获取文件属性的，<code>stat </code>函数是 <code>Linux </code>中的系统调用，用于获取文件相关的信息。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int stat(const char *pathname, struct stat *buf);</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">struct stat</span><br><span class="line">&#123;</span><br><span class="line">	 dev_t st_dev; /* 文件所在设备的 ID */</span><br><span class="line">	 ino_t st_ino; /* 文件对应 inode 节点编号 */</span><br><span class="line">	 mode_t st_mode; /* 文件对应的模式 */</span><br><span class="line">	 nlink_t st_nlink; /* 文件的链接数 */</span><br><span class="line">	 uid_t st_uid; /* 文件所有者的用户 ID */</span><br><span class="line">	 gid_t st_gid; /* 文件所有者的组 ID */</span><br><span class="line">	 dev_t st_rdev; /* 设备号（指针对设备文件） */</span><br><span class="line">	 off_t st_size; /* 文件大小（以字节为单位） */</span><br><span class="line">	 blksize_t st_blksize; /* 文件内容存储的块大小 */</span><br><span class="line">	 blkcnt_t st_blocks; /* 文件内容所占块数 */</span><br><span class="line">	 struct timespec st_atim; /* 文件最后被访问的时间 */</span><br><span class="line">	 struct timespec st_mtim; /* 文件内容最后被修改的时间 */</span><br><span class="line">	 struct timespec st_ctim; /* 文件状态最后被改变的时间 */</span><br><span class="line">&#125;;</span><br><span class="line">st_dev：该字段用于描述此文件所在的设备。不常用，可以不用理会。</span><br><span class="line">st_ino：文件的 inode 编号。</span><br><span class="line">st_mode：该字段用于描述文件的模式，譬如文件类型、文件权限都记录在该变量中。</span><br><span class="line">st_nlink：该字段用于记录文件的硬链接数，也就是为该文件创建了多少个硬链接文件。链接文件可以分为软链接（符号链接）文件和硬链接文件。</span><br><span class="line">st_uid、st_gid：此两个字段分别用于描述文件所有者的用户 ID 以及文件所有者的组 ID。</span><br><span class="line">st_rdev：该字段记录了设备号，设备号只针对于设备文件，包括字符设备文件和块设备文件，不用理会。</span><br><span class="line">st_size：该字段记录了文件的大小（逻辑大小），以字节为单位。</span><br><span class="line">st_atim、st_mtim、st_ctim：此三个字段分别用于记录文件最后被访问的时间、文件内容最后被修改的时间以及文件状态最后被改变的时间，都是 struct timespec 类型变量。</span><br></pre></td></tr></table></figure>

<h4 id="5-3-解析请求行（parseRequestLine函数）"><a href="#5-3-解析请求行（parseRequestLine函数）" class="headerlink" title="5.3 解析请求行（parseRequestLine函数）"></a>5.3 解析请求行（parseRequestLine函数）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">parseRequestLine</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* line,<span class="type">int</span> cfd)</span>&#123;</span><br><span class="line">    <span class="comment">// 1. 拆分http请求行   get /xxx/1.jpg http/1.1</span></span><br><span class="line">    <span class="type">char</span> method[<span class="number">12</span>];    <span class="comment">// 方法</span></span><br><span class="line">    <span class="type">char</span> path[<span class="number">1024</span>];    <span class="comment">// 路径</span></span><br><span class="line">    <span class="type">char</span> protocol[<span class="number">12</span>];  <span class="comment">// 协议</span></span><br><span class="line">    <span class="built_in">sscanf</span>(line,<span class="string">&quot;%[^ ] %[^ ] %[^ ]&quot;</span>,method,path,protocol);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;method = %s, path = %s, protocol = %s\n&quot;</span>, method, path, protocol);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否是get请求</span></span><br><span class="line">    <span class="keyword">if</span>(strcasecmp(method,<span class="string">&quot;get&quot;</span>) != <span class="number">0</span>)&#123;     <span class="comment">//不区分大小写</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转码 将不能识别的中文乱码 -&gt; 中文</span></span><br><span class="line">    <span class="comment">// 解码 %23 %34 %5f</span></span><br><span class="line">    decode_str(path, path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 处理客户端请求的静态资源</span></span><br><span class="line">    <span class="type">char</span>* file = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 如果没有指定访问的资源, 默认显示资源目录中的内容</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(path,<span class="string">&quot;/&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// file的值, 资源目录的当前位置</span></span><br><span class="line">        file = <span class="string">&quot;./&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 去掉path中的/ 获取访问文件名</span></span><br><span class="line">        file = path + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 获取文件属性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="type">int</span> ret = stat(file,&amp;st);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 文件不存在--回复404</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断文件类型（判断是目录还是文件）</span></span><br><span class="line">    <span class="keyword">if</span>(S_ISDIR(st.st_mode))&#123;    <span class="comment">// 目录</span></span><br><span class="line">        <span class="comment">// 把目录发给客户端</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 把文件内容发给客户端</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-发送响应头"><a href="#6-发送响应头" class="headerlink" title="6. 发送响应头"></a>6. 发送响应头</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sendHeadMsg</span><span class="params">(<span class="type">int</span> cfd,<span class="type">int</span> status,<span class="type">const</span> <span class="type">char</span>* desrc,<span class="type">const</span> <span class="type">char</span>* type,<span class="type">int</span> length)</span>&#123;</span><br><span class="line">    <span class="comment">// 状态行</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4096</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(buf,<span class="string">&quot;http/1.1 %d %s \r\n&quot;</span>,status,desrc);</span><br><span class="line">    <span class="comment">// 消息报头</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf + <span class="built_in">strlen</span>(buf),<span class="string">&quot;Content-Type: %s\r\n&quot;</span>,type);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf + <span class="built_in">strlen</span>(buf),<span class="string">&quot;Content-Length: %d\r\n&quot;</span>,length);</span><br><span class="line"></span><br><span class="line">    send(cfd,buf,<span class="built_in">strlen</span>(buf),<span class="number">0</span>);</span><br><span class="line">     <span class="comment">// 空行</span></span><br><span class="line">    send(cfd, <span class="string">&quot;\r\n&quot;</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-通过文件名获取文件的类型"><a href="#7-通过文件名获取文件的类型" class="headerlink" title="7. 通过文件名获取文件的类型"></a>7. 通过文件名获取文件的类型</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过文件名获取文件的类型</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">get_file_type</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* dot;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自右向左查找‘.’字符, 如不存在返回NULL</span></span><br><span class="line">    dot = <span class="built_in">strrchr</span>(name, <span class="string">&#x27;.&#x27;</span>);   </span><br><span class="line">    <span class="keyword">if</span> (dot == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;text/plain; charset=utf-8&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.html&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.htm&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;text/html; charset=utf-8&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.jpg&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.jpeg&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;image/jpeg&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.gif&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;image/gif&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.png&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;image/png&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.css&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;text/css&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.au&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;audio/basic&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>( dot, <span class="string">&quot;.wav&quot;</span> ) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;audio/wav&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.avi&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;video/x-msvideo&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.mov&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.qt&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;video/quicktime&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.mpeg&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.mpe&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;video/mpeg&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.vrml&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.wrl&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;model/vrml&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.midi&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.mid&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;audio/midi&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.mp3&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;audio/mpeg&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.ogg&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;application/ogg&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.pac&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;application/x-ns-proxy-autoconfig&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;text/plain; charset=utf-8&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-发送文件"><a href="#8-发送文件" class="headerlink" title="8. 发送文件"></a>8. 发送文件</h3><h4 id="8-1-断言（assert函数）"><a href="#8-1-断言（assert函数）" class="headerlink" title="8.1 断言（assert函数）"></a>8.1 断言（assert函数）</h4><p>编译期<code>assert</code>函数的目的在于当条件不满足时，阻止编译，从而防止错误的逻辑通过编辑。而运行期<code>assert</code>的目的在于运行时发现条件不满足时，产生一个<code>Debug</code>事件(<code>DebugBreak</code>)，从而让调试器停下来方便用户检查原因。<code>assert </code>是一个宏，不是函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//表达式可以是任何有效的 C 语言表达式，很多时候它是一个条件。</span><br><span class="line">void assert(int expression or variable);</span><br></pre></td></tr></table></figure>

<h4 id="8-2-光标函数（lseek函数）"><a href="#8-2-光标函数（lseek函数）" class="headerlink" title="8.2 光标函数（lseek函数）"></a>8.2 光标函数（lseek函数）</h4><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt; </span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">off_t lseek(int handle, off_t offset, int fromwhere);</span><br><span class="line">1) 欲将读写位置移到文件开头时:</span><br><span class="line">lseek（int fildes,0,SEEK_SET）；</span><br><span class="line">2) 欲将读写位置移到文件尾时:</span><br><span class="line">lseek（int fildes，0,SEEK_END）；</span><br><span class="line">3) 想要取得目前文件位置时:</span><br><span class="line">lseek（int fildes，0,SEEK_CUR）；</span><br></pre></td></tr></table></figure>

<h4 id="8-3-发送文件（sendFile函数）"><a href="#8-3-发送文件（sendFile函数）" class="headerlink" title="8.3 发送文件（sendFile函数）"></a>8.3 发送文件（sendFile函数）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sendFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename,<span class="type">int</span> cfd)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(filename,O_RDONLY);</span><br><span class="line">    assert(fd &gt; <span class="number">0</span>);     <span class="comment">// 断言</span></span><br><span class="line">    <span class="comment">// if(fd == -1)&#123;</span></span><br><span class="line">    <span class="comment">//     perror(&quot;open error&quot;);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 2. 循环读文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4096</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((len = read(fd,buf,<span class="keyword">sizeof</span>(buf))) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 发送读出的数据</span></span><br><span class="line">        ret = send(cfd,buf,len,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(errno = EAGAIN)&#123;</span><br><span class="line">                perror(<span class="string">&quot;send error:&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">                perror(<span class="string">&quot;send error:&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                perror(<span class="string">&quot;send error:&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">off_t</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> size = lseek(fd,<span class="number">0</span>,SEEK_END);</span><br><span class="line">    lseek(fd,<span class="number">0</span>,SEEK_SET);</span><br><span class="line">    <span class="keyword">while</span>(offset &lt; size)&#123;</span><br><span class="line">        <span class="type">int</span> ret = sendfile(cfd,fd,&amp;offset,size);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret value: %d\n&quot;</span>,ret);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span> &amp;&amp; errno == EAGAIN)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没数据。。。\n&quot;</span>);</span><br><span class="line">            perror(<span class="string">&quot;snedfile&quot;</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-发送目录"><a href="#9-发送目录" class="headerlink" title="9. 发送目录"></a>9. 发送目录</h3><h4 id="9-1-目录扫描函数（scandir函数）"><a href="#9-1-目录扫描函数（scandir函数）" class="headerlink" title="9.1 目录扫描函数（scandir函数）"></a>9.1 目录扫描函数（scandir函数）</h4><p><code>scandir()</code>会扫描参数<code>dir</code>指定的目录文件，经由参数<code>select</code>指定的函数来挑选目录结构至参数<code>namelist</code>数组中，最后再调用参数<code>compar</code>指定的函数来排序<code>namelist</code>数组中的目录数据。每次从目录文件中读取一个目录结构后便将此结构传给参数<code>select</code>所指的函数，<code>select</code>函数若不想要将此目录结构复制到<code>namelis</code>t数组就返回0，若<code>select</code>为空指针则代表选择所有的目录结构。<code>scandir()</code>会调用<code>qsort()</code>来排序数据，参数<code>compar</code>则为<code>qsort()</code>的参数，若是要排列目录名称字母则可使用<code>alphasort()</code>。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">#include &lt;dirent.h&gt;</span><br><span class="line">int scandir(const char *dir, </span><br><span class="line">			struct dirent ***namelist,</span><br><span class="line">			int (*select)(const struct dirent *),</span><br><span class="line">			int (*compar)(const struct dirent **, </span><br><span class="line">			const struct dirent **));</span><br><span class="line">dir:指定扫描的目录</span><br><span class="line">namelist:struct dirent结构体类型的三级指针，用于获取该函数内部为存放返回结果的分配的动态内存</span><br><span class="line">select:函数指针，指向过滤模式函数,当selectr指针设置为NULL时，扫描dir目录下的所有顶层文件.该函数有一个参数const struct dirent *是指在遍历过程中所遍历到的每一个子目录dirent，select可以根据dirent的类型、名称等信息来判定当前的dirent是否为合法的子目录，合法则函数返回0，则该子目录的名称会被存储在namelist中；否则返回非0，则该子目录被过滤掉。</span><br><span class="line">compar:函数指针，指向对遍历结果进行排序函数，alphasort函数和versionsort是经常用到的函数</span><br></pre></td></tr></table></figure>

<h4 id="9-2-发送目录（sendDir函数）"><a href="#9-2-发送目录（sendDir函数）" class="headerlink" title="9.2 发送目录（sendDir函数）"></a>9.2 发送目录（sendDir函数）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送目录内容</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sendDir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* dirname, <span class="type">int</span> cfd)</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 拼接一个html页面&lt;table&gt;&lt;/table&gt;</span></span><br><span class="line">   <span class="type">char</span> buf[<span class="number">4096</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">sprintf</span>(buf,<span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;目录名：%s&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt;&quot;</span>,dirname);</span><br><span class="line">   <span class="comment">//sprintf(buf + strlen(buf),&quot;&lt;body&gt;&lt;h1&gt;当前目录：%s&lt;/h1&gt;&lt;table&gt;&quot;,dirname);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目录项二级指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>** <span class="title">ptr</span>;</span></span><br><span class="line">    <span class="type">int</span> num = scandir(dirname,&amp;ptr,<span class="literal">NULL</span>,alphasort);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历目录</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="comment">// 取出文件名 namelist 指向的是一个指针数组 struct dirent* tmp[]</span></span><br><span class="line">        <span class="type">char</span>* name = ptr[i]-&gt;d_name;</span><br><span class="line">        <span class="type">char</span> subPath[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="comment">// 拼接文件袋完整路径</span></span><br><span class="line">        <span class="built_in">sprintf</span>(subPath,<span class="string">&quot;%s/%s&quot;</span>,dirname,name);</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">        stat(subPath,&amp;st);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> enstr[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// 编码生成 %E5 %A7 之类的东西</span></span><br><span class="line">        encode_str(enstr, <span class="keyword">sizeof</span>(enstr), name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是文件</span></span><br><span class="line">        <span class="keyword">if</span>(S_ISREG(st.st_mode)) &#123;       </span><br><span class="line">            <span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf), </span><br><span class="line">                    <span class="string">&quot;&lt;tr&gt;&lt;td&gt;&lt;a href=\&quot;%s\&quot;&gt;%s&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%ld&lt;/td&gt;&lt;/tr&gt;&quot;</span>,</span><br><span class="line">                    enstr, name, (<span class="type">long</span>)st.st_size);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(S_ISDIR(st.st_mode)) &#123;		<span class="comment">// 如果是目录       </span></span><br><span class="line">            <span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf), </span><br><span class="line">                    <span class="string">&quot;&lt;tr&gt;&lt;td&gt;&lt;a href=\&quot;%s/\&quot;&gt;%s/&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%ld&lt;/td&gt;&lt;/tr&gt;&quot;</span>,</span><br><span class="line">                    enstr, name, (<span class="type">long</span>)st.st_size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ret = send(cfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EAGAIN) &#123;</span><br><span class="line">                perror(<span class="string">&quot;send error:&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">                perror(<span class="string">&quot;send error:&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                perror(<span class="string">&quot;send error:&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="comment">// 字符串拼接</span></span><br><span class="line">        <span class="built_in">free</span>(ptr[i]);</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字符串拼接</span></span><br><span class="line">    <span class="comment">//memset(buf, 0, sizeof(buf));</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>);</span><br><span class="line">    send(cfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dir message send OK!!!!\n&quot;</span>); </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    <span class="comment">// 打开目录</span></span><br><span class="line">    DIR* dir = opendir(dirname);</span><br><span class="line">    <span class="keyword">if</span>(dir == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;opendir error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读目录</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">ptr</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>( (ptr = readdir(dir)) != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span>* name = ptr-&gt;d_name;</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(dir);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-完整代码"><a href="#10-完整代码" class="headerlink" title="10. 完整代码"></a>10. 完整代码</h3><h4 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h4><p><img   src="https://glf-1309623969.cos.ap-shanghai.myqcloud.com/img/image-20231028135200278.png"  alt="image-20231028135200278"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">客户端: 浏览器</span></span><br><span class="line"><span class="comment">	- 通过浏览器访问服务器:</span></span><br><span class="line"><span class="comment">		- 访问方式: 服务器的IP地址:端口</span></span><br><span class="line"><span class="comment">	- 应用层协议使用: http, 数据需要在浏览器端使用该协议进行包装</span></span><br><span class="line"><span class="comment">	- 响应消息的处理也是浏览器完成的 =&gt; 程序猿不需要管</span></span><br><span class="line"><span class="comment">	- 客户端通过url访问服务器资源</span></span><br><span class="line"><span class="comment">		- 客户端访问的路径:</span></span><br><span class="line"><span class="comment">		1. http://192.168.1.100:8989/  或者  http://192.168.1.100:8989</span></span><br><span class="line"><span class="comment">			- 访问服务器提供的资源目录的根目录</span></span><br><span class="line"><span class="comment">				- 并不是服务器上的 / 目录  </span></span><br><span class="line"><span class="comment">				- 这个目录根据服务器端的描述应该是: /home/robin/luffy 目录</span></span><br><span class="line"><span class="comment">			- 请求行:</span></span><br><span class="line"><span class="comment">				GET / HTTP/1.1</span></span><br><span class="line"><span class="comment">		2. http://192.168.1.100:8989/a.txt</span></span><br><span class="line"><span class="comment">			- 端口后边的/代表服务器的资源根目录</span></span><br><span class="line"><span class="comment">				- 在服务器端路径: /home/robin/luffy 目录</span></span><br><span class="line"><span class="comment">			- 客户端要访问服务器上的a.txt的文件</span></span><br><span class="line"><span class="comment">			- a.txt 这个文件在服务器提供的资源目录中</span></span><br><span class="line"><span class="comment">				- 服务器上的路径: /home/robin/luffy/a.txt</span></span><br><span class="line"><span class="comment">			- 请求行:</span></span><br><span class="line"><span class="comment">				GET /a.txt HTTP/1.1</span></span><br><span class="line"><span class="comment">		3. http://192.168.1.100:8989/hello/a.txt</span></span><br><span class="line"><span class="comment">			- http://192.168.1.100:8989: 服务器地址</span></span><br><span class="line"><span class="comment">			- /hello/a.txt</span></span><br><span class="line"><span class="comment">				- /: 服务器端提供的资源根目录</span></span><br><span class="line"><span class="comment">				- hello: 资源根目录的子目录</span></span><br><span class="line"><span class="comment">				- a.txt: 在hello目录中</span></span><br><span class="line"><span class="comment">			- 请求行:</span></span><br><span class="line"><span class="comment">				GET /hello/a.txt HTTP/1.1</span></span><br><span class="line"><span class="comment">		4. http://192.168.1.100:8989/hello/wrold/</span></span><br><span class="line"><span class="comment">			- http://192.168.1.100:8989: 服务器地址</span></span><br><span class="line"><span class="comment">			- /hello/world/</span></span><br><span class="line"><span class="comment">				- /: 服务器端提供的资源根目录</span></span><br><span class="line"><span class="comment">				- hello: 资源根目录的子目录</span></span><br><span class="line"><span class="comment">				- world/: 如果world后边有/代表这是一个目录, 这个目录在hello目录中</span></span><br><span class="line"><span class="comment">			- 请求行:</span></span><br><span class="line"><span class="comment">				GET /hello/world/ HTTP/1.1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">服务器端: 提供服务器, 让客户端访问</span></span><br><span class="line"><span class="comment">	- 支持多客户端访问</span></span><br><span class="line"><span class="comment">		- 使用IO多路转接 =&gt; epoll</span></span><br><span class="line"><span class="comment">	- 客户端发送给的请求消息是基于http的</span></span><br><span class="line"><span class="comment">		- 需要能够解析http请求</span></span><br><span class="line"><span class="comment">	- 服务器回复客户端数据, 使用http协议封装回复的数据 ==&gt; http响应</span></span><br><span class="line"><span class="comment">	- 服务器端需要提供一个资源目录, 目录中的文件可以供客户端访问</span></span><br><span class="line"><span class="comment">		- 客户端访问的文件没有在资源目录中, 就不能访问了</span></span><br><span class="line"><span class="comment">			- 假设服务器提供个资源目录: /home/robin/luffy 目录</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务器端处理的伪代码</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建监听的fd</span></span><br><span class="line">    socket();</span><br><span class="line">    <span class="comment">// 2. 绑定</span></span><br><span class="line">    bind();</span><br><span class="line">    <span class="comment">// 3. 设置监听</span></span><br><span class="line">    listen();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 创建epoll模型</span></span><br><span class="line">    epoll_create();</span><br><span class="line">    epoll_ctl();</span><br><span class="line">    <span class="comment">// 5. 检测</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        epoll_wait();</span><br><span class="line">        <span class="comment">// 监听的文件描述符</span></span><br><span class="line">        accept();</span><br><span class="line">        <span class="comment">// 通信的</span></span><br><span class="line">        <span class="comment">// 接收数据-&gt;http请求消息</span></span><br><span class="line">        recvAndParseHttp();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于边沿非阻塞模型接收数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">recvAndParseHttp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 循环接收数据</span></span><br><span class="line">    <span class="comment">// 解析http请求消息</span></span><br><span class="line">    <span class="comment">// http请求由两种:get / post</span></span><br><span class="line">    <span class="comment">// 只处理get请求, 浏览器向服务器请求访问的文件都是静态资源, 因此使用get就可以</span></span><br><span class="line">    <span class="comment">// 判断是不是get请求  ==&gt; 在请求行中 ==&gt; 请求行的第一部分</span></span><br><span class="line">    <span class="comment">// 客户端向服务器请求的静态资源是什么? =&gt; 请求行的第二部分</span></span><br><span class="line">    <span class="comment">// 找到服务器上的静态资源</span></span><br><span class="line">    	- 文件 -&gt; 读文件内容</span><br><span class="line">        - 目录 -&gt; 遍历目录</span><br><span class="line">    <span class="comment">// 将文件内容或者目录内容打包到http响应协议中</span></span><br><span class="line">    <span class="comment">// 将整条协议发送回给客户端即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="epoll-web-c"><a href="#epoll-web-c" class="headerlink" title="epoll_web.c"></a><strong>epoll_web.c</strong></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;epoll_web.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="comment">// 初始化监听套接字</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">initListenFd</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> port)</span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建监听套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 设置端口复用</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ret = setsockopt(lfd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,<span class="keyword">sizeof</span>(opt));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(port);</span><br><span class="line">    addr.sin_addr.s_addr = <span class="number">0</span>;</span><br><span class="line">    ret = bind(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;addr,<span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.设置监听</span></span><br><span class="line">    ret = listen(lfd,<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 返回fd</span></span><br><span class="line">    <span class="keyword">return</span> lfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动epoll</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epollrun</span><span class="params">(<span class="type">int</span> lfd)</span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建epoll树</span></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(epfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. lfd上树</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.data.fd = lfd;</span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    <span class="type">int</span> ret = epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&amp;ev);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_ctl error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 检测(委托内核检测添加到树上的节点)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">evs</span>[1024];</span></span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>(evs) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> epoll_event);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> num = epoll_wait(epfd,evs,size,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait error&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历发生变化的节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!(evs[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line">                <span class="comment">// 不是读事件</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> fd = evs[i].data.fd;</span><br><span class="line">            <span class="keyword">if</span>(fd == lfd)&#123;</span><br><span class="line">                <span class="comment">//建立新连接accept</span></span><br><span class="line">                accpetClient(lfd,epfd);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 读数据</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;=============before recvHttpRequest=============\n&quot;</span>);</span><br><span class="line">                recvHttpRequest(fd,epfd);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;=============after recvHttpRequest=============\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">accpetClient</span><span class="params">(<span class="type">int</span> lfd,<span class="type">int</span> epfd)</span>&#123;</span><br><span class="line">    <span class="comment">// 1. 建立连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    cliaddr.sin_family = AF_INET;</span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd,(<span class="keyword">struct</span> sockaddr*)&amp;cliaddr,&amp;len);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> ip[<span class="number">16</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;new client ip=%s port=%d\n&quot;</span>,</span><br><span class="line">    inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr,ip,<span class="number">16</span>),ntohs(cliaddr.sin_port));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 设置cfd为非阻塞</span></span><br><span class="line">    <span class="type">int</span> flag = fcntl(cfd,F_GETFL);</span><br><span class="line">    flag |= O_NONBLOCK;</span><br><span class="line">    fcntl(cfd,F_SETFL,flag);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. cfd添加到epoll</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.data.fd = cfd;</span><br><span class="line">    <span class="comment">// 边沿非阻塞模式</span></span><br><span class="line">    ev.events = EPOLLIN | EPOLLET;      <span class="comment">//边沿模式</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&amp;ev);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_ctl error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">recvHttpRequest</span><span class="params">(<span class="type">int</span> cfd,<span class="type">int</span> epfd)</span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4096</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">char</span> tmp[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 1. 接收数据</span></span><br><span class="line">    <span class="keyword">while</span>((len = recv(cfd,tmp,<span class="keyword">sizeof</span>(tmp),<span class="number">0</span>)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(total + len &lt; <span class="keyword">sizeof</span>(buf))&#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(buf + total,tmp,len);</span><br><span class="line">        &#125;</span><br><span class="line">        total += len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 判断数据是否接受完毕</span></span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">-1</span> &amp;&amp; errno == EAGAIN)&#123;</span><br><span class="line">        <span class="comment">// 解析请求行   </span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19</span></span><br><span class="line"><span class="comment">        G E T   / 1 . t x t H  T  T  P  /  1  .  1  /r /n</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">char</span>* pt = <span class="built_in">strstr</span>(buf,<span class="string">&quot;\r\n&quot;</span>);  <span class="comment">//大字符串找小字符串</span></span><br><span class="line">        <span class="type">int</span> reqLen = pt - buf;</span><br><span class="line">        buf[reqLen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        parseRequestLine(buf,cfd);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 客户端断开连接</span></span><br><span class="line">        epoll_ctl(epfd,EPOLL_CTL_DEL,cfd,<span class="literal">NULL</span>);</span><br><span class="line">        close(cfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        perror(<span class="string">&quot;recv error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">parseRequestLine</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* line,<span class="type">int</span> cfd)</span>&#123;</span><br><span class="line">    <span class="comment">// 1. 拆分http请求行   get /xxx/1.jpg http/1.1</span></span><br><span class="line">    <span class="type">char</span> method[<span class="number">12</span>];    <span class="comment">// 方法</span></span><br><span class="line">    <span class="type">char</span> path[<span class="number">1024</span>];    <span class="comment">// 路径</span></span><br><span class="line">    <span class="type">char</span> protocol[<span class="number">12</span>];  <span class="comment">// 协议</span></span><br><span class="line">    <span class="built_in">sscanf</span>(line,<span class="string">&quot;%[^ ] %[^ ] %[^ ]&quot;</span>,method,path,protocol);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;method = %s, path = %s, protocol = %s\n&quot;</span>, method, path, protocol);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否是get请求</span></span><br><span class="line">    <span class="keyword">if</span>(strcasecmp(method,<span class="string">&quot;get&quot;</span>) != <span class="number">0</span>)&#123;     <span class="comment">//不区分大小写</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转码 将不能识别的中文乱码 -&gt; 中文</span></span><br><span class="line">    <span class="comment">// 解码 %23 %34 %5f</span></span><br><span class="line">    decode_str(path, path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 处理客户端请求的静态资源</span></span><br><span class="line">    <span class="type">char</span>* file = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 如果没有指定访问的资源, 默认显示资源目录中的内容</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(path,<span class="string">&quot;/&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// file的值, 资源目录的当前位置</span></span><br><span class="line">        file = <span class="string">&quot;./&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 去掉path中的/ 获取访问文件名</span></span><br><span class="line">        file = path + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 获取文件属性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="type">int</span> ret = stat(file,&amp;st);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 文件不存在--回复404</span></span><br><span class="line">        sendHeadMsg(cfd,<span class="number">404</span>,<span class="string">&quot;Not Found&quot;</span>,get_file_type(<span class="string">&quot;.html&quot;</span>),<span class="number">-1</span>);</span><br><span class="line">        sendFile(<span class="string">&quot;404.html&quot;</span>,cfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断文件类型（判断是目录还是文件）</span></span><br><span class="line">    <span class="keyword">if</span>(S_ISDIR(st.st_mode))&#123;    <span class="comment">// 目录</span></span><br><span class="line">        <span class="comment">// 把目录发给客户端</span></span><br><span class="line">         sendHeadMsg(cfd,<span class="number">200</span>,<span class="string">&quot;OK&quot;</span>,get_file_type(<span class="string">&quot;.html&quot;</span>),<span class="number">-1</span>);</span><br><span class="line">         sendDir(file,cfd);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 把文件内容发给客户端</span></span><br><span class="line">        sendHeadMsg(cfd,<span class="number">200</span>,<span class="string">&quot;OK&quot;</span>,get_file_type(file),st.st_size);</span><br><span class="line">        sendFile(file,cfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sendHeadMsg</span><span class="params">(<span class="type">int</span> cfd,<span class="type">int</span> status,<span class="type">const</span> <span class="type">char</span>* desrc,<span class="type">const</span> <span class="type">char</span>* type,<span class="type">int</span> length)</span>&#123;</span><br><span class="line">    <span class="comment">// 状态行</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4096</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(buf,<span class="string">&quot;http/1.1 %d %s \r\n&quot;</span>,status,desrc);</span><br><span class="line">    <span class="comment">// 消息报头</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf + <span class="built_in">strlen</span>(buf),<span class="string">&quot;Content-Type: %s\r\n&quot;</span>,type);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf + <span class="built_in">strlen</span>(buf),<span class="string">&quot;Content-Length: %d\r\n&quot;</span>,length);</span><br><span class="line"></span><br><span class="line">    send(cfd,buf,<span class="built_in">strlen</span>(buf),<span class="number">0</span>);</span><br><span class="line">     <span class="comment">// 空行</span></span><br><span class="line">    send(cfd, <span class="string">&quot;\r\n&quot;</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sendFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename,<span class="type">int</span> cfd)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(filename,O_RDONLY);</span><br><span class="line">    assert(fd &gt; <span class="number">0</span>);     <span class="comment">// 断言</span></span><br><span class="line">    <span class="comment">// if(fd == -1)&#123;</span></span><br><span class="line">    <span class="comment">//     perror(&quot;open error&quot;);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 2. 循环读文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4096</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((len = read(fd,buf,<span class="keyword">sizeof</span>(buf))) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 发送读出的数据</span></span><br><span class="line">        ret = send(cfd,buf,len,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(errno = EAGAIN)&#123;</span><br><span class="line">                perror(<span class="string">&quot;send error:&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">                perror(<span class="string">&quot;send error:&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                perror(<span class="string">&quot;send error:&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">off_t</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> size = lseek(fd,<span class="number">0</span>,SEEK_END);</span><br><span class="line">    lseek(fd,<span class="number">0</span>,SEEK_SET);</span><br><span class="line">    <span class="keyword">while</span>(offset &lt; size)&#123;</span><br><span class="line">        <span class="type">int</span> ret = sendfile(cfd,fd,&amp;offset,size);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret value: %d\n&quot;</span>,ret);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span> &amp;&amp; errno == EAGAIN)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没数据。。。\n&quot;</span>);</span><br><span class="line">            perror(<span class="string">&quot;snedfile&quot;</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送目录内容</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sendDir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* dirname, <span class="type">int</span> cfd)</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 拼接一个html页面&lt;table&gt;&lt;/table&gt;</span></span><br><span class="line">   <span class="type">char</span> buf[<span class="number">4096</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">sprintf</span>(buf,<span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;目录名：%s&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt;&quot;</span>,dirname);</span><br><span class="line">   <span class="comment">//sprintf(buf + strlen(buf),&quot;&lt;body&gt;&lt;h1&gt;当前目录：%s&lt;/h1&gt;&lt;table&gt;&quot;,dirname);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目录项二级指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>** <span class="title">ptr</span>;</span></span><br><span class="line">    <span class="type">int</span> num = scandir(dirname,&amp;ptr,<span class="literal">NULL</span>,alphasort);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历目录</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="comment">// 取出文件名 namelist 指向的是一个指针数组 struct dirent* tmp[]</span></span><br><span class="line">        <span class="type">char</span>* name = ptr[i]-&gt;d_name;</span><br><span class="line">        <span class="type">char</span> subPath[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="comment">// 拼接文件袋完整路径</span></span><br><span class="line">        <span class="built_in">sprintf</span>(subPath,<span class="string">&quot;%s/%s&quot;</span>,dirname,name);</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">        stat(subPath,&amp;st);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> enstr[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// 编码生成 %E5 %A7 之类的东西</span></span><br><span class="line">        encode_str(enstr, <span class="keyword">sizeof</span>(enstr), name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是文件</span></span><br><span class="line">        <span class="keyword">if</span>(S_ISREG(st.st_mode)) &#123;       </span><br><span class="line">            <span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf), </span><br><span class="line">                    <span class="string">&quot;&lt;tr&gt;&lt;td&gt;&lt;a href=\&quot;%s\&quot;&gt;%s&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%ld&lt;/td&gt;&lt;/tr&gt;&quot;</span>,</span><br><span class="line">                    enstr, name, (<span class="type">long</span>)st.st_size);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(S_ISDIR(st.st_mode)) &#123;		<span class="comment">// 如果是目录       </span></span><br><span class="line">            <span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf), </span><br><span class="line">                    <span class="string">&quot;&lt;tr&gt;&lt;td&gt;&lt;a href=\&quot;%s/\&quot;&gt;%s/&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%ld&lt;/td&gt;&lt;/tr&gt;&quot;</span>,</span><br><span class="line">                    enstr, name, (<span class="type">long</span>)st.st_size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ret = send(cfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EAGAIN) &#123;</span><br><span class="line">                perror(<span class="string">&quot;send error:&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">                perror(<span class="string">&quot;send error:&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                perror(<span class="string">&quot;send error:&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="comment">// 字符串拼接</span></span><br><span class="line">        <span class="built_in">free</span>(ptr[i]);</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字符串拼接</span></span><br><span class="line">    <span class="comment">//memset(buf, 0, sizeof(buf));</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>);</span><br><span class="line">    send(cfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dir message send OK!!!!\n&quot;</span>); </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    <span class="comment">// 打开目录</span></span><br><span class="line">    DIR* dir = opendir(dirname);</span><br><span class="line">    <span class="keyword">if</span>(dir == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;opendir error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读目录</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">ptr</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>( (ptr = readdir(dir)) != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span>* name = ptr-&gt;d_name;</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(dir);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  这里的内容是处理%20之类的东西！是&quot;解码&quot;过程。</span></span><br><span class="line"><span class="comment"> *  %20 URL编码中的‘ ’(space)</span></span><br><span class="line"><span class="comment"> *  %21 &#x27;!&#x27; %22 &#x27;&quot;&#x27; %23 &#x27;#&#x27; %24 &#x27;$&#x27;</span></span><br><span class="line"><span class="comment"> *  %25 &#x27;%&#x27; %26 &#x27;&amp;&#x27; %27 &#x27;&#x27;&#x27; %28 &#x27;(&#x27;......</span></span><br><span class="line"><span class="comment"> *  相关知识html中的‘ ’(space)是&amp;nbsp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 16进制数转化为10进制</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hexit</span><span class="params">(<span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">encode_str</span><span class="params">(<span class="type">char</span>* to, <span class="type">int</span> tosize, <span class="type">const</span> <span class="type">char</span>* from)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tolen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (tolen = <span class="number">0</span>; *from != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; tolen + <span class="number">4</span> &lt; tosize; ++from) &#123;    </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isalnum</span>(*from) || <span class="built_in">strchr</span>(<span class="string">&quot;/_.-~&quot;</span>, *from) != (<span class="type">char</span>*)<span class="number">0</span>) &#123;      </span><br><span class="line">            *to = *from;</span><br><span class="line">            ++to;</span><br><span class="line">            ++tolen;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(to, <span class="string">&quot;%%%02x&quot;</span>, (<span class="type">int</span>) *from &amp; <span class="number">0xff</span>);</span><br><span class="line">            to += <span class="number">3</span>;</span><br><span class="line">            tolen += <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *to = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">decode_str</span><span class="params">(<span class="type">char</span> *to, <span class="type">char</span> *from)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; *from != <span class="string">&#x27;\0&#x27;</span>; ++to, ++from  ) &#123;     </span><br><span class="line">        <span class="keyword">if</span> (from[<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span> &amp;&amp; <span class="built_in">isxdigit</span>(from[<span class="number">1</span>]) &amp;&amp; <span class="built_in">isxdigit</span>(from[<span class="number">2</span>])) &#123;       </span><br><span class="line">            *to = hexit(from[<span class="number">1</span>])*<span class="number">16</span> + hexit(from[<span class="number">2</span>]);</span><br><span class="line">            from += <span class="number">2</span>;                      </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *to = *from;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *to = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过文件名获取文件的类型</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">get_file_type</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* dot;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自右向左查找‘.’字符, 如不存在返回NULL</span></span><br><span class="line">    dot = <span class="built_in">strrchr</span>(name, <span class="string">&#x27;.&#x27;</span>);   </span><br><span class="line">    <span class="keyword">if</span> (dot == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;text/plain; charset=utf-8&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.html&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.htm&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;text/html; charset=utf-8&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.jpg&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.jpeg&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;image/jpeg&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.gif&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;image/gif&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.png&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;image/png&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.css&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;text/css&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.au&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;audio/basic&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>( dot, <span class="string">&quot;.wav&quot;</span> ) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;audio/wav&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.avi&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;video/x-msvideo&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.mov&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.qt&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;video/quicktime&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.mpeg&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.mpe&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;video/mpeg&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.vrml&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.wrl&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;model/vrml&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.midi&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.mid&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;audio/midi&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.mp3&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;audio/mpeg&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.ogg&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;application/ogg&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.pac&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;application/x-ns-proxy-autoconfig&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;text/plain; charset=utf-8&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="epoll-web-h"><a href="#epoll-web-h" class="headerlink" title="epoll_web.h"></a><strong>epoll_web.h</strong></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _EPOLL_SEVER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _EPOLL_SEVER_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化监听的套接字</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">initListenFd</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> port)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动epoll</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epollrun</span><span class="params">(<span class="type">int</span> lfd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立新连接</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">accpetClient</span><span class="params">(<span class="type">int</span> lfd,<span class="type">int</span> epfd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">recvHttpRequest</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> epfd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析请求行</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parseRequestLine</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* line,<span class="type">int</span> cfd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送响应头（状态行+响应头）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sendHeadMsg</span><span class="params">(<span class="type">int</span> cfd,<span class="type">int</span> status,<span class="type">const</span> <span class="type">char</span>* desrc,<span class="type">const</span> <span class="type">char</span>* type,<span class="type">int</span> length)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sendFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename,<span class="type">int</span> cfd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送目录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sendDir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* dirName,<span class="type">int</span> cfd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过文件名获取文件的类型</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">get_file_type</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hexit</span><span class="params">(<span class="type">char</span> c)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">encode_str</span><span class="params">(<span class="type">char</span>* to, <span class="type">int</span> tosize, <span class="type">const</span> <span class="type">char</span>* from)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">decode_str</span><span class="params">(<span class="type">char</span> *to, <span class="type">char</span> *from)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;epoll_web.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;./a.out port path\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 采用指定端口</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改进程工作目录，方便后续操作</span></span><br><span class="line">    <span class="type">int</span> ret = chdir(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;chdir error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化监听套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = initListenFd(port);</span><br><span class="line">    <span class="comment">// 启动epoll模型</span></span><br><span class="line">    epollrun(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>C++ 网络编程 WebServer</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针</title>
    <url>/2024/06/18/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><h2 id="智能指针的作用"><a href="#智能指针的作用" class="headerlink" title="智能指针的作用"></a>智能指针的作用</h2><p> C++程序设计中使用堆内存是非常频繁的操作，堆内存的申请和释放都由程序员自己管理。程序员自己管理堆内存可以提高了程序的效率，但是整体来说堆内存的管理是麻烦的，C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。</p>
<p>理解智能指针需要从下面三个层次：</p>
<ol>
<li>从较浅的层面看，智能指针是利用了一种叫做<code>RAII</code>（资源获取即初始化）的技术对普通的指针进行封装，这使得智能指针实质是一个对象，行为表现的却像一个指针。</li>
<li>智能指针的作用是<strong>防止忘记调用delete释放内存和程序异常的进入catch块忘记释放内存</strong>。另外指针的释放时机也是非常有考究的，多次释放同一个指针会造成程序崩溃，这些都可以通过智能指针来解决。</li>
<li>智能指针还有一个作用是把值语义转换成引用语义</li>
</ol>
<h2 id="智能指针和管理的对象分别在哪个区"><a href="#智能指针和管理的对象分别在哪个区" class="headerlink" title="智能指针和管理的对象分别在哪个区"></a>智能指针和管理的对象分别在哪个区</h2><p>智能指针本身在栈区，托管的资源在堆区，利用了栈对象超出生命周期后自动析构的特征，所以无需手动delete释放资源。</p>
<p>智能指针对象位于栈内存，管理一个堆内存的对象，当智能指针对象的生命周期结束后，会在析构函数中释放掉管理的堆内存资源，从而防止堆内存对象内存泄漏。</p>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/ce2c572fde6840209d1ba3ea4c157df5.png"  alt="img"></p>
<h2 id="unique-ptr能否被另一个unique-ptr拷贝呢？"><a href="#unique-ptr能否被另一个unique-ptr拷贝呢？" class="headerlink" title="unique_ptr能否被另一个unique_ptr拷贝呢？"></a>unique_ptr能否被另一个unique_ptr拷贝呢？</h2><ul>
<li>不能，因为它把它的拷贝构造函数<code>private</code>了。但是它提供了一个移动构造函数，所以可以通过<code>std::move</code>将指针指向的对象交给另一个<code>unique_ptr</code>，转交之后自己就失去了这个指针对象的所有权，除非被显示交回。</li>
</ul>
<h2 id="unique-ptr-unique-ptr和shared-ptr-shared-ptr这两个操作有什么后果呢？"><a href="#unique-ptr-unique-ptr和shared-ptr-shared-ptr这两个操作有什么后果呢？" class="headerlink" title="unique_ptr &#x3D; unique_ptr和shared_ptr&#x3D;shared_ptr这两个操作有什么后果呢？"></a>unique_ptr &#x3D; unique_ptr和shared_ptr&#x3D;shared_ptr这两个操作有什么后果呢？</h2><p>对于unique_ptr&#96; ：</p>
<ul>
<li>这个操作是不允许的，因为<code>unique_ptr</code>它的原理是将拷贝构造和拷贝赋值私有化，但是它提供了移动构造和移动赋值。所以如果你想要使用&#x3D;赋值，必须先把右边的用<code>std::move</code>包裹一下，这样右边的<code>unique_ptr</code>就会失去所有权，左边的<code>unique_ptr</code>就会得到对应对象的所有权</li>
</ul>
<p>至于<code>shared_ptr</code>：</p>
<ul>
<li>对于左边的指针，它会将自己的引用计数减一，然后检测一下是不是减到了0，如果是，那么<code>delete</code>所管理的对象</li>
<li>然后将右边的引用计数和管理对象赋值给左边，此时两边指向同一个对象，共享同一个引用计数，然后引用计数++</li>
</ul>
<h2 id="shared-ptr的移动赋值时发生了什么事情"><a href="#shared-ptr的移动赋值时发生了什么事情" class="headerlink" title="shared_ptr的移动赋值时发生了什么事情"></a>shared_ptr的移动赋值时发生了什么事情</h2><ul>
<li>首先它会检查本指针和参数指针是不是同一个对象，如果是，直接返回</li>
<li>然后，先把本指针的引用变量–1，如果发现减到了0，就把参数指针和参数引用变量析构掉并置NULL</li>
<li>最后，本指针和参数指针指向同一个对象以及引用计数，然后引用计数自增1</li>
</ul>
<h2 id="unique-ptr和shared-ptr的区别"><a href="#unique-ptr和shared-ptr的区别" class="headerlink" title="unique_ptr和shared_ptr的区别"></a>unique_ptr和shared_ptr的区别</h2><ul>
<li><p><code>unique_ptr</code>代表的是专属所有权，不支持复制和赋值。但是可以移动</p>
</li>
<li><p><code>shared_ptr </code>代表的是共享所有权，<code>shared_ptr </code>是支持复制的和赋值以及移动的</p>
</li>
<li><p><code>unique_ptr </code>在默认情况下和裸指针的大小是一样的。<br>所以 内存上没有任何的额外消耗，性能是最优的，我们大多数场景下用到的应该都是<code> unique_ptr</code>。</p>
</li>
<li><p><code>shared_ptr </code>的内存占用是裸指针的两倍。因为除了要管理一个裸指针外，还要维护一个引用计数。因此相比于 <code>unique_ptr</code>, <code>shared_ptr</code> 的内存占用更高。在使用 <code>shared_ptr</code> 之前应该考虑，是否真的需要使用 <code>shared_ptr</code>, 而非 <code>unique_ptr</code>。</p>
<h2 id="shared-ptr你是怎么实现的"><a href="#shared-ptr你是怎么实现的" class="headerlink" title="shared_ptr你是怎么实现的"></a>shared_ptr你是怎么实现的</h2><p><code>shared_ptr</code> 内部是利用引用计数来实现内存的自动管理，每当复制一个 <code>shared_ptr</code>，引用计数会 + 1。当一个 <code>shared_ptr</code>离开作用域时，引用计数会 - 1。当引用计数为 0 的时候，则 <code>delete</code> 内存。</p>
<h2 id="shared-ptr是不是线程安全"><a href="#shared-ptr是不是线程安全" class="headerlink" title="shared_ptr是不是线程安全"></a>shared_ptr是不是线程安全</h2><ul>
<li><p>不是</p>
</li>
<li><p>引用计数的增减是原子操作没问题，但是<code>shared_pytr</code>的读写本身不只包括引用计数操作，还包括资源所有权的操作，这两个操作合起来不是原子的</p>
</li>
<li><p>如果要求线程安全必须加锁</p>
</li>
<li><p><strong>资源所有权操作不是线程安全的</strong>：包括指针的赋值和删除操作，如果在多线程环境中使用，需要加锁保护。</p>
<p><strong>加锁保护资源所有权操作</strong>：在多线程环境中对 <code>shared_ptr</code> 的赋值或修改操作应使用互斥锁（如 <code>std::mutex</code>）来保护，以确保线程安全。</p>
</li>
</ul>
<h2 id="weak-ptr如何检测指针是否被销毁"><a href="#weak-ptr如何检测指针是否被销毁" class="headerlink" title="weak_ptr如何检测指针是否被销毁"></a>weak_ptr如何检测指针是否被销毁</h2><p><code>expired()</code>：</p>
<ul>
<li>判断强引用计数是否为0</li>
<li>如果返回true，那么被观测的对象(也就是<code>shared_ptr</code>管理的资源)已经不存在了</li>
</ul>
<h2 id="如何将weak-ptr转换为shared-ptr"><a href="#如何将weak-ptr转换为shared-ptr" class="headerlink" title="如何将weak_ptr转换为shared_ptr"></a>如何将weak_ptr转换为shared_ptr</h2><p>用<code>lock()</code>:</p>
<ul>
<li>如果<code>expired()</code>为true，返回一个空<code>shared_ptr</code>，否则返回非空<code>shared_ptr</code></li>
</ul>
</li>
</ul>
<h2 id="智能指针的设计与实现"><a href="#智能指针的设计与实现" class="headerlink" title="智能指针的设计与实现"></a>智能指针的设计与实现</h2><blockquote>
<p>智能指针类将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。每次创建类的新对象时，初始化指针并将引用计数置为1；当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）。智能指针就是模拟指针动作的类。所有的智能指针都会重载 -&gt; 和 * 操作符。智能指针还有许多其他功能，比较有用的是自动销毁。这主要是利用栈对象的有限作用域以及临时对象（有限作用域实现）析构函数释放内存。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPointer</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _ptr;</span><br><span class="line">    atomic_int* _count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmartPointer</span>(T* ptr = <span class="literal">nullptr</span>) :</span><br><span class="line">            _ptr(ptr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_ptr) &#123;</span><br><span class="line">            _count = <span class="keyword">new</span> <span class="built_in">size_t</span>(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _count = <span class="keyword">new</span> <span class="built_in">size_t</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">SmartPointer</span>(<span class="type">const</span> SmartPointer&amp; ptr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;ptr) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_ptr = ptr._ptr;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_count = ptr._count;</span><br><span class="line">            (*<span class="keyword">this</span>-&gt;_count)++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//拷贝赋值</span></span><br><span class="line">    SmartPointer&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SmartPointer&amp; ptr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_ptr == ptr._ptr) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_ptr) &#123;</span><br><span class="line">            (*<span class="keyword">this</span>-&gt;_count)--;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">                <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;_ptr = ptr._ptr;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_count = ptr._count;</span><br><span class="line">        (*<span class="keyword">this</span>-&gt;_count)++;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 解引用</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() &#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="keyword">this</span>-&gt;_ptr != <span class="literal">nullptr</span>); <span class="comment">// 断言指针不为空</span></span><br><span class="line">        <span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;_ptr);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="keyword">this</span>-&gt;_ptr == <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">SmartPointer</span>() &#123;</span><br><span class="line">        (*<span class="keyword">this</span>-&gt;_count)--;</span><br><span class="line">        <span class="keyword">if</span> (*<span class="keyword">this</span>-&gt;_count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">use_count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>-&gt;_count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">SmartPointer&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">        <span class="function">SmartPointer&lt;<span class="type">int</span>&gt; <span class="title">sp2</span><span class="params">(sp)</span></span>;</span><br><span class="line">        <span class="function">SmartPointer&lt;<span class="type">int</span>&gt; <span class="title">sp3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">20</span>))</span></span>;</span><br><span class="line">        sp2 = sp3;</span><br><span class="line">        std::cout &lt;&lt; sp.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; sp3.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//delete operator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p><code>shared_ptr</code>使用了引用计数，每一个<code>shared_ptr</code>的拷贝都指向相同的内存，每次拷贝都会触发引用计数+1，每次生命周期结束析构的时候引用计数-1，在最后一个<code>shared_ptr</code>析构的时候，内存才会释放。</p>
<p>关于<code>shared_ptr</code>有几点需要注意：</p>
<p>• 不要用一个裸指针初始化多个<code>shared_ptr</code>，会出现<code>double_free</code>导致程序崩溃</p>
<p>• 通过<code>shared_from_this()</code>返回<code>this</code>指针，不要把<code>this</code>指针作为<code>shared_ptr</code>返回出来，因为<code>this</code>指针本质就是裸指针，通过<code>this</code>返回可能会导致重复析构，不能把<code>this</code>指针交给智能指针管理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">GetSelf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">        <span class="comment">// return shared_ptr&lt;A&gt;(this); 错误，会导致double free</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>尽量使用<code>make_shared</code>，少用<code>new</code>。</li>
<li>不要<code>delete get()</code>返回来的裸指针。</li>
<li>不是<code>new</code>出来的空间要自定义删除器。</li>
<li>要避免循环引用，循环引用导致内存永远不会被释放，造成内存泄漏。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ClassWrapper</span> &#123;</span><br><span class="line">    <span class="built_in">ClassWrapper</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">ClassWrapper</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;deconstruct&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;print&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(std::shared_ptr&lt;ClassWrapper&gt; ptr)</span> </span>&#123;</span><br><span class="line">    ptr-&gt;<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> smart_ptr = std::<span class="built_in">make_shared</span>&lt;ClassWrapper&gt;();</span><br><span class="line">    <span class="keyword">auto</span> ptr2 = smart_ptr; <span class="comment">// 引用计数+1</span></span><br><span class="line">    ptr2-&gt;<span class="built_in">Print</span>();</span><br><span class="line">    <span class="built_in">Func</span>(smart_ptr); <span class="comment">// 引用计数+1</span></span><br><span class="line">    smart_ptr-&gt;<span class="built_in">Print</span>();</span><br><span class="line">    ClassWrapper *p = smart_ptr.<span class="built_in">get</span>(); <span class="comment">// 可以通过get获取裸指针</span></span><br><span class="line">    p-&gt;<span class="built_in">Print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">construct</span><br><span class="line">print</span><br><span class="line">print</span><br><span class="line">print</span><br><span class="line">print</span><br><span class="line">deconstruct</span><br></pre></td></tr></table></figure>

<h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p><code>weak_ptr</code>是用来监视<code>shared_ptr</code>的生命周期，它不管理<code>shared_ptr</code>内部的指针，它的拷贝的析构都不会影响引用计数，纯粹是作为一个旁观者监视<code>shared_ptr</code>中管理的资源是否存在，可以用来返回<code>this</code>指针和解决循环引用问题。</p>
<ul>
<li>作用1：返回<code>this</code>指针，上面介绍的<code>shared_from_this()</code>其实就是通过<code>weak_ptr</code>返回的<code>this</code>指针。</li>
<li>作用2：解决循环引用问题。</li>
</ul>
<p>空悬指针问题：有两个指针<code>p1</code>和<code>p2</code>，指向堆上的同一个对象<code>Object</code>，<code>p1</code>和<code>p2</code>位于不同的线程中。假设线程A通过p1指针将对象销毁了（尽管把<code>p1</code>置为了NULL），那<code>p2</code>就成了空悬指针。</p>
<p><code>weak_ptr</code>不控制对象的生命期，但是它知道对象是否还活着。如果对象还活着，那么它可以提升为有效的<code>shared_ptr</code>（提升操作通过<code>lock()</code>函数获取所管理对象的强引用指针）；如果对象已经死了，提升会失败，返回一个空的<code>shared_ptr</code>。</p>
<blockquote>
<p>1）operator&#x3D;()：重载 &#x3D; 赋值运算符，是的 weak_ptr 指针可以直接被 weak_ptr 或者 shared_ptr 类型指针赋值。<br>2）swap(x)：其中 x 表示一个同类型的 weak_ptr 类型指针，该函数可以互换 2 个同类型 weak_ptr 指针的内容。<br>3）reset()：将当前 weak_ptr 指针置为空指针。<br>4）use_count()：查看指向和当前 weak_ptr 指针相同的 shared_ptr 指针的数量。<br>5）expired()：判断当前 weak_ptr 指针为否过期（指针为空，或者指向的堆内存已经被释放）。<br>6）lock()：如果当前 weak_ptr 已经过期，则该函数会返回一个空的 shared_ptr 指针；反之，该函数返回一个和当前 weak_ptr 指向相同的 shared_ptr 指针。</p>
</blockquote>
<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p><code>std::unique_ptr</code>是一个独占型的智能指针，它不允许其它智能指针共享其内部指针，也不允许<code>unique_ptr</code>的拷贝和赋值。使用方法和<code>shared_ptr</code>类似，区别是不可以拷贝</p>
]]></content>
      <categories>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>C++ 智能指针</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯后端开发QQ部门一面</title>
    <url>/2024/04/23/%E8%85%BE%E8%AE%AF%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91QQ%E9%83%A8%E9%97%A8%E4%B8%80%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="腾讯面经"><a href="#腾讯面经" class="headerlink" title="腾讯面经"></a>腾讯面经</h1><h2 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h2><ol>
<li><strong>管道（Pipe）：</strong> 管道是一种半双工的通信方式，用于在父进程和子进程之间传递数据。它只能在具有亲缘关系的进程之间使用，例如父子进程或者兄弟进程。管道可以是匿名的，也可以是有名字的。</li>
<li><strong>命名管道（Named Pipe）：</strong> 命名管道是一种特殊的管道，允许在无亲缘关系的进程之间进行通信。它通过文件系统中的特殊文件来实现，具有持久性和独立性的特点。</li>
<li><strong>消息队列（Message Queue）：</strong> 消息队列是一种通过消息传递方式进行进程间通信的机制。它允许一个进程向队列中发送消息，另一个进程从队列中接收消息，实现了异步、解耦合和灵活性的通信方式。</li>
<li><strong>信号量（Semaphore）：</strong> 信号量是一种用于控制多个进程对共享资源的访问的机制。它通过计数器来实现，允许多个进程同时访问共享资源，但可以限制同时访问的进程数量。</li>
<li><strong>共享内存（Shared Memory）：</strong> 共享内存是一种高效的进程间通信方式，允许多个进程共享同一块物理内存区域。它通过将内存映射到进程的地址空间中来实现，使得多个进程可以直接访问共享的数据，而无需进行复制或者传输。</li>
<li><strong>套接字（Socket）：</strong> 套接字是一种用于在网络中进行进程间通信的接口。它允许不同主机上的进程之间通过网络进行数据交换，实现了跨主机的进程通信。</li>
<li><strong>信号（Signal）：</strong> 信号是一种用于通知进程发生了某个事件的机制。它可以在进程之间进行简单的异步通信，例如进程可以通过发送信号来通知另一个进程发生了某个事件，另一个进程可以通过信号处理函数来处理这个事件。</li>
</ol>
<h2 id="tcp三次握手、四次挥手"><a href="#tcp三次握手、四次挥手" class="headerlink" title="tcp三次握手、四次挥手"></a>tcp三次握手、四次挥手</h2><p>一开始，客户端和服务端都处于 <code>CLOSE</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态。</p>
<ul>
<li><p>客户端会随机初始化序号（<code>client_isn</code>），将此序号置于 TCP 首部的「序号」字段中，同时把 <code>SYN</code> 标志位置为 <code>1</code>，表示 <code>SYN</code> 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <code>SYN-SENT</code> 状态。</p>
</li>
<li><p>服务端收到客户端的 <code>SYN</code> 报文后，首先服务端也随机初始化自己的序号（<code>server_isn</code>），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 <code>client_isn + 1</code>, 接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <code>1</code>。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 <code>SYN-RCVD</code> 状态。</p>
</li>
<li><p>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code>ACK</code> 标志位置为 <code>1</code> ，其次「确认应答号」字段填入 <code>server_isn + 1</code> ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 <code>ESTABLISHED</code> 状态。</p>
</li>
<li><p>服务端收到客户端的应答报文后，也进入 <code>ESTABLISHED</code> 状态。</p>
</li>
</ul>
<p>三次握手的<strong>首要原因是为了防止旧的重复连接初始化造成混乱。</strong></p>
<h2 id="protobuf和json的优缺点"><a href="#protobuf和json的优缺点" class="headerlink" title="protobuf和json的优缺点"></a>protobuf和json的优缺点</h2><p><strong>优势</strong></p>
<ul>
<li><strong>极高的效率：</strong> <code>ProtoBuf</code>以二进制格式存储数据，比文本格式的<code>JSON</code>小得多，从而减少了传输时间和存储空间。</li>
<li><strong>强大的数据类型支持：</strong> <code>ProtoBuf</code>支持各种数据类型，包括基本类型、枚举、消息和可重复字段，使其非常适合处理复杂的数据结构；<strong>无类型</strong>：<code>JSON</code>是一种无类型的数据格式，因此在数据校验和一致性方面不如<code>protobuf</code>。</li>
<li><strong>强大的序列化和反序列化性能：</strong> <code>ProtoBuf</code>提供了高效的序列化和反序列化库，可以快速将数据转换为二进制格式，并在需要时将其转换回原始对象。</li>
</ul>
<p><strong>劣势</strong></p>
<ul>
<li><strong>语言无关性：</strong> <code>JSON</code>是一种语言无关的数据格式，可以轻松地与各种编程语言集成。</li>
<li><strong>可读性差</strong>：由于是二进制格式，不易人类阅读和调试。<code>JSON</code>是一种文本格式，易于人类阅读和编写。</li>
</ul>
<h2 id="异步日志为什么要用单例模式"><a href="#异步日志为什么要用单例模式" class="headerlink" title="异步日志为什么要用单例模式"></a>异步日志为什么要用单例模式</h2><ol>
<li><strong>全局唯一性：</strong> 异步日志通常需要在整个程序中被访问和使用，因此需要确保日志实例的全局唯一性，以避免多个日志实例之间的冲突和混乱。单例模式确保了在整个程序中只有一个日志实例存在。</li>
<li><strong>方便访问：</strong> 使用单例模式可以通过静态方法或者全局函数来获取日志实例，从而方便在程序的任何地方使用相同的日志实例进行记录，而无需传递日志实例的引用。</li>
<li><strong>线程安全性：</strong> 异步日志通常会在多个线程中被同时使用，因此需要考虑线程安全性。单例模式可以在实现时考虑线程安全性，并确保日志实例的创建和访问都是线程安全的。</li>
</ol>
<h2 id="static修饰的变量和全局变量有什么区别"><a href="#static修饰的变量和全局变量有什么区别" class="headerlink" title="static修饰的变量和全局变量有什么区别"></a>static修饰的变量和全局变量有什么区别</h2><ol>
<li><strong>作用域</strong>:<ul>
<li>全局变量在整个程序中都是可见的，可以被任何函数访问。</li>
<li><code>static</code>修饰的变量只在定义它的函数内部可见，其作用域被限制在定义它的函数内部。</li>
</ul>
</li>
<li><strong>生存周期</strong>:<ul>
<li>全局变量在程序运行期间始终存在，直到程序结束。</li>
<li><code>static</code>修饰的变量也在程序运行期间存在，但其生命周期与程序中对应的函数调用有关。当包含<code>static</code>变量的函数执行完毕时，<code>static</code>变量仍然存在，但其值会保持上一次函数调用结束时的状态。</li>
</ul>
</li>
<li><strong>存储位置</strong>:<ul>
<li>全局变量存储在静态存储区，程序在启动时就会为全局变量分配内存。</li>
<li><code>static</code>修饰的变量也存储在静态存储区，但只有在<strong>其所在的函数第一次被调用时才会分配内存</strong>。</li>
</ul>
</li>
<li><strong>访问权限</strong>:<ul>
<li>全局变量可以被程序中的任何函数访问。</li>
<li><code>static</code>修饰的变量只能被定义它的函数访问，其他函数无法直接访问该变量。</li>
</ul>
</li>
</ol>
<h2 id="epoll的底层原理"><a href="#epoll的底层原理" class="headerlink" title="epoll的底层原理"></a>epoll的底层原理</h2><p><code>epoll</code> 是 Linux 下的一种 I&#x2F;O 多路复用机制，用于处理大量并发连接或操作。它通过操作系统内核提供的 <code>epoll</code> 系统调用来管理文件描述符并监视 I&#x2F;O 事件。</p>
<ol>
<li><strong>事件驱动模型：</strong> <code>epoll</code> 是基于<strong>事件驱动</strong>的模型。它利用操作系统内核的事件通知机制来通知应用程序发生了哪些 I&#x2F;O 事件，例如套接字可读、套接字可写等。</li>
<li><strong>注册事件：</strong> 应用程序可以通过 <code>epoll_ctl</code> 系统调用向内核注册需要监视的文件描述符以及对应的事件类型（读、写等）。一旦文件描述符上发生了指定的事件，内核就会通知应用程序。</li>
<li><strong>等待事件：</strong> 应用程序使用 <code>epoll_wait</code> 系统调用来等待事件的发生。当有文件描述符上发生了注册的事件时，<code>epoll_wait</code> 将返回并通知应用程序。</li>
<li><strong>高效处理事件：</strong> <code>epoll</code> 的高效性体现在它在等待事件发生时不会阻塞整个进程，而是采用了非阻塞的方式。它通过内核态和用户态之间的数据结构共享，避免了频繁的上下文切换，从而提高了性能。</li>
<li><strong>可扩展性：</strong> <code>epoll</code> 在设计上考虑了可扩展性，能够有效地处理大量的并发连接或操作。它使用红黑树（Red-Black Tree）和双链表（Doubly Linked List）等数据结构来管理文件描述符，从而减少了对文件描述符数量的限制。</li>
</ol>
<h2 id="什么情况下需要I-O多路复用技术"><a href="#什么情况下需要I-O多路复用技术" class="headerlink" title="什么情况下需要I&#x2F;O多路复用技术"></a>什么情况下需要I&#x2F;O多路复用技术</h2><p>传统的 I&#x2F;O 模型中，每个连接或操作都需要一个独立的线程或进程来处理，这会消耗大量的系统资源。而使用 I&#x2F;O 多路复用技术，可以通过一个线程或进程同时监听多个 I&#x2F;O 事件，从而减少了资源的消耗。</p>
<p><strong>IO多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态</strong>，比如调用select和poll函数，传入多个文件描述符，<strong>如果有一个文件描述符就绪，则返回，否则阻塞直到超时</strong>。</p>
<p>这样在处理1000个连接时，<strong>只需要1个线程监控就绪状态，对就绪的每个连接开一个线程处理就可以了，这样需要的线程数大大减少，减少了内存开销和上下文切换的CPU开销。</strong></p>
<h2 id="tcp三次握手期间，ddos攻击"><a href="#tcp三次握手期间，ddos攻击" class="headerlink" title="tcp三次握手期间，ddos攻击"></a>tcp三次握手期间，ddos攻击</h2><p>“分布式拒绝服务”，即利用大量合法的分布式服务器对目标发送请求，从而导致正常合法用户无法获得服务。</p>
<p>通过发送伪造源<code>IP</code>的TCP数据包发送<code>SYN</code>或<code>ACK</code>包、发送包含错误设置的地址值等攻击方式，<strong>耗尽服务器资源，导致服务器拒绝访问</strong>。</p>
<h2 id="在没有IO多路复用的时候，早年的网络服务器，如PHP写的他们是怎么处理连接的，采用什么技术"><a href="#在没有IO多路复用的时候，早年的网络服务器，如PHP写的他们是怎么处理连接的，采用什么技术" class="headerlink" title="在没有IO多路复用的时候，早年的网络服务器，如PHP写的他们是怎么处理连接的，采用什么技术"></a>在没有IO多路复用的时候，早年的网络服务器，如PHP写的他们是怎么处理连接的，采用什么技术</h2><p><strong>多进程&#x2F;多线程模型：</strong> 服务器启动时创建多个进程或线程来处理连接。每个连接都被分配给一个独立的进程或线程来处理，这样可以同时处理多个连接。</p>
<p><strong>阻塞式 I&#x2F;O：</strong>当有新连接到来时，服务器将为其分配一个进程或线程，并在该进程或线程中使用阻塞式 I&#x2F;O 来处理连接。</p>
<p><strong>进程池&#x2F;线程池：</strong> 为了避免频繁地创建和销毁进程或线程带来的开销，服务器可能会使用进程池或线程池来管理连接处理的进程或线程。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">const</span> string &amp;T, vector&lt;<span class="type">int</span>&gt; &amp;next)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; T.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(j != <span class="number">0</span> &amp;&amp; T[i] != T[j])&#123;</span><br><span class="line">            <span class="comment">// 找前一位的对应的回退位置</span></span><br><span class="line">			j = next[j<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(s[i] == s[j])&#123;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		next[i] = j;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">KMP</span><span class="params">(string &amp;S ,string &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = S.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> m = T.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(m,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">getNext</span>(T,next);</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; S[i] != T[j])&#123;</span><br><span class="line">            j = next[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(S[i] == T[j])&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == m)&#123;</span><br><span class="line">            <span class="keyword">return</span> (i - m + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数说明：a --待排序的数组</span></span><br><span class="line"><span class="comment">		l --数组的左边界</span></span><br><span class="line"><span class="comment">		r --数组的右边界</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a,<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> i,j,k;</span><br><span class="line">        i = l;</span><br><span class="line">        j = r;</span><br><span class="line">        k = a[i];</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; k &gt; a[j])&#123;</span><br><span class="line">                j--;	<span class="comment">// 从右向左找第一个大于k的数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">                a[i++] = a[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; k &lt; a[i])&#123;</span><br><span class="line">                i++;	<span class="comment">// 从左向右找第一个小于k的数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">                a[j--] = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[i] = k;</span><br><span class="line">        <span class="built_in">quick_sort</span>(a,l,i<span class="number">-1</span>);	<span class="comment">//递归调用</span></span><br><span class="line">        <span class="built_in">quick_sort</span>(a,i+<span class="number">1</span>,r);	<span class="comment">//递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> key,value;</span><br><span class="line">    Node* prev;</span><br><span class="line">    Node* next;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> k = <span class="number">0</span>, <span class="type">int</span> v = <span class="number">0</span>) :<span class="built_in">key</span>(k),<span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    Node *dummy;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,Node*&gt; key_to_node;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(Node *x)</span></span>&#123;</span><br><span class="line">        x-&gt;prev-&gt;next = x-&gt;next;</span><br><span class="line">        x-&gt;next-&gt;prev = x-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(Node *x)</span></span>&#123;</span><br><span class="line">        x-&gt;prev = dummy;</span><br><span class="line">        x-&gt;next = dummy-&gt;next;</span><br><span class="line">        x-&gt;prev-&gt;next= x;</span><br><span class="line">        x-&gt;next-&gt;prev = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Node *<span class="title">get_node</span><span class="params">(<span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = key_to_node.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(it == key_to_node.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> node = it-&gt;second;</span><br><span class="line">        <span class="built_in">remove</span>(node);</span><br><span class="line">        <span class="built_in">push_front</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity)</span><br><span class="line">     : <span class="built_in">capacity</span>(capacity),</span><br><span class="line">     <span class="built_in">dummy</span>(<span class="keyword">new</span> <span class="built_in">Node</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        dummy-&gt;prev = dummy;</span><br><span class="line">        dummy-&gt;next = dummy;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> node = <span class="built_in">get_node</span>(key);</span><br><span class="line">        <span class="keyword">return</span> node ? node-&gt;value:<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> node = <span class="built_in">get_node</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(node)&#123;</span><br><span class="line">            node-&gt;value = value;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        key_to_node[key] = node = <span class="keyword">new</span> <span class="built_in">Node</span>(key,value);</span><br><span class="line">        <span class="built_in">push_front</span>(node);</span><br><span class="line">        <span class="keyword">if</span>(key_to_node.<span class="built_in">size</span>() &gt; capacity)&#123;</span><br><span class="line">            <span class="keyword">auto</span> back_node = dummy-&gt;prev;</span><br><span class="line">            key_to_node.<span class="built_in">erase</span>(back_node-&gt;key);</span><br><span class="line">            <span class="built_in">remove</span>(back_node);</span><br><span class="line">            <span class="keyword">delete</span> back_node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="top-K"><a href="#top-K" class="headerlink" title="top K"></a>top K</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; p1, <span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; p2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p1.second &gt; p2.second;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 统计频率</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:nums)&#123;</span><br><span class="line">        mp[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义堆</span></span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,cmp&gt; pq;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:mp)&#123;</span><br><span class="line">        pq.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(pq.<span class="built_in">size</span>() &gt; k)&#123;</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(pq.<span class="built_in">top</span>().first);</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; m, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; n)</span>  </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> m.second &gt; n.second;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, <span class="keyword">decltype</span>(&amp;cmp)&gt; <span class="built_in">q</span>(cmp);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里使用了decltype关键词（since c++11）并传入cmp函数的地址，所以第三个模板参数的类型实际上是一个静态函数指针，于是q实例化了一个该模板类的类型出来，但这也只是声明出了一个函数指针而已。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">根据priority_queue的构造函数explicit priority_queue (const Compare&amp; comp = Compare(), const Container&amp; ctnr = Container())，通过q(cmp)将cmp这个函数指针赋值给之前在类中声明出的函数指针，从而完成优先队列q的构造。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>后端开发 C++</tag>
      </tags>
  </entry>
  <entry>
    <title>虚函数</title>
    <url>/2024/06/19/%E8%99%9A%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><h3 id="什么是虚函数"><a href="#什么是虚函数" class="headerlink" title="什么是虚函数"></a>什么是虚函数</h3><p>虚函数是在基类中声明的，而在派生类中进行重写的函数。通过使用<code>virtual</code>关键字声明一个函数为虚函数，它使得在运行时能够动态地确定调用的是哪个版本的函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base class\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived class\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="虚函数的作用"><a href="#虚函数的作用" class="headerlink" title="虚函数的作用"></a><strong>虚函数的作用</strong></h3><ul>
<li>实现多态性（Polymorphism）：允许通过基类指针或引用调用派生类对象的函数，根据实际对象的类型选择相应的函数实现。</li>
<li>运行时绑定（Runtime Binding）：虚函数通过表格（虚函数表）的方式实现，使得在运行时动态地绑定函数调用。</li>
</ul>
<h3 id="虚函数表（vtable）"><a href="#虚函数表（vtable）" class="headerlink" title="虚函数表（vtable）"></a><strong>虚函数表（vtable）</strong></h3><p>每个含有虚函数的类都有一个虚函数表，其中<strong>存储了虚函数的地址</strong>。对象的内存布局中包含一个指向虚函数表的指针。派生类的虚函数表包含基类的虚函数表，并在适当的位置添加或替换新的虚函数地址。</p>
<h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a><strong>纯虚函数</strong></h3><p><strong>纯虚函数是一个在基类中声明但没有提供实现的虚函数</strong>，它通过在声明中使用<code>= 0</code>来标识。类含有纯虚函数的类被称为<strong>抽象类</strong>，不能被实例化。派生类必须实现纯虚函数，否则也会变为抽象类。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractBase</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">pureVirtualFunction</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a><strong>虚析构函数</strong></h3><p>如果基类的析构函数是虚函数，当通过基类指针删除派生类对象时，会调用派生类的析构函数。这是为了确保正确的对象销毁。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base destructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Derived</span>() <span class="keyword">override</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived destructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/2021032617400189.png"  alt="img"></p>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/image-20240612122221519.png"  alt="image-20240612122221519"></p>
<h3 id="构造函数可以是虚函数吗？析构函数呢？"><a href="#构造函数可以是虚函数吗？析构函数呢？" class="headerlink" title="构造函数可以是虚函数吗？析构函数呢？"></a>构造函数可以是虚函数吗？析构函数呢？</h3><p><strong>C++中，构造函数不可以是虚函数，而析构函数可以且常常是虚函数。</strong></p>
<p>从存储空间角度，虚函数相应一个指向vtable虚函数表的指针，但是这个指向vtable的指针事实上是存储在对象的内存空间的。假设构造函数是虚的，就须要通过 vtable来调用，但是<strong>对象</strong>还<strong>没有实例化</strong>，也就是<strong>内存空间</strong>还<strong>没有</strong>，找不到<strong>vtable</strong></p>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/20210303163930516.png"  alt="img"></p>
<h3 id="在析构函数中写delete-this可以吗？在类中的其他函数中写呢？"><a href="#在析构函数中写delete-this可以吗？在类中的其他函数中写呢？" class="headerlink" title="在析构函数中写delete this可以吗？在类中的其他函数中写呢？"></a>在析构函数中写delete this可以吗？在类中的其他函数中写呢？</h3><p><strong>this指针</strong>：当一个对象声明时，系统会为这个对象分配一块内存空间，this指针指向这块内存空间，这块空间里面存着对象的数据成员和虚函数表指针。</p>
<p><strong>使用delete的时候</strong>：第一步，针对此内存会有一个（或更多）析构函数被调用，第二步才会释放该内存。</p>
<p><strong>在成员函数中调用delete this，会导致指针错误，而在析构函数中调用delete this，出导致死循环，造成堆栈溢出。</strong></p>
<p><strong>指针大小只与操作系统位数相关，如64位机器，为8字节</strong></p>
<h3 id="哪些函数不能为虚函数"><a href="#哪些函数不能为虚函数" class="headerlink" title="哪些函数不能为虚函数?"></a>哪些函数不能为虚函数?</h3><p>构造函数、静态函数、友元函数、内联函数</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ol>
<li><strong>派生类对象初始化先调用基类构造再调派生类构造</strong>。</li>
<li><strong>派生类对象析构清理先调用派生类析构再调基类的析构</strong>。</li>
</ol>
<p><img   src="https://mzy777.oss-cn-hangzhou.aliyuncs.com/img/image-20240415195059387.png"  alt="image-20240415195059387"></p>
<p>⭕<strong>基类定义了<code>static</code>静态成员，则整个继承体系里面只有一个这样的成员。无论派生出多少个子类，都只有一个<code>static</code>成员实例</strong> 。</p>
<h3 id="虚析构函数的作用"><a href="#虚析构函数的作用" class="headerlink" title="虚析构函数的作用"></a>虚析构函数的作用</h3><p>虚析构函数使得在<strong>删除指向子类对象的基类指针</strong>时可以<strong>调用子类的析构函数</strong>达到释放子类中堆内存的目的，而防止内存泄露的。</p>
<p><strong>C++虚函数表保存在.rdata只读数据段</strong></p>
]]></content>
      <categories>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>C++ 虚函数</tag>
      </tags>
  </entry>
</search>
